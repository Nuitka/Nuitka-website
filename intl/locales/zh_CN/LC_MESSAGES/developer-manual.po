# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Kay Hayen and Nuitka Contributors
# This file is distributed under the same license as the Nuitka the Python
# Compiler package.
# xinetzone <735613050@qq.com>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Nuitka the Python Compiler \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-09 23:30+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: xinetzone <735613050@qq.com>, 2022\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../Nuitka-main/Developer_Manual.rst:3
msgid "Nuitka Developer Manual"
msgstr "Nuitka 开发者手册"

#: ../../Nuitka-main/Developer_Manual.rst:898
msgid "Nuitka Logo"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:8
msgid "Contents"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:10
msgid ""
"The purpose of this Developer Manual is to present the current design of "
"Nuitka, the project rules, and the motivations for choices made. It is "
"intended to be a guide to the source code, and to give explanations that "
"don't fit into the source code in comments form."
msgstr "本开发者手册的目的是介绍 Nuitka 的当前设计、项目规则以及所做选择的动机。它旨在成为源代码的指南，并以注释的形式给出不适合源代码的解释。"

#: ../../Nuitka-main/Developer_Manual.rst:15
msgid ""
"It should be used as a reference for the process of planning and "
"documenting decisions we made. Therefore we are e.g. presenting here the "
"type inference plans before implementing them. And we update them as we "
"proceed."
msgstr "它应该被用作规划和记录我们所做决定过程的参考。因此，我们在这里，例如，在实施类型推理计划之前，提出了这些计划。而且我们在进行过程中更新它们。"

#: ../../Nuitka-main/Developer_Manual.rst:20
msgid ""
"It grows out of discussions and presentations made at conferences as well"
" as private conversations or issue tracker."
msgstr "它是从会议上的讨论和演讲以及私人谈话或问题跟踪器中成长起来的。"

#: ../../Nuitka-main/Developer_Manual.rst:25
msgid "Milestones"
msgstr "里程碑"

#: ../../Nuitka-main/Developer_Manual.rst:27
msgid ""
"Feature parity with CPython, understand all the language construct and "
"behave absolutely compatible."
msgstr "与 CPython 的功能相当，理解所有的语言构造，行为上绝对兼容。"

#: ../../Nuitka-main/Developer_Manual.rst:30
msgid ""
"Feature parity has been reached for CPython 2.6 and 2.7. We do not target"
" any older CPython release. For CPython 3.3 up to 3.8 it also has been "
"reached. We do not target the older and practically unused CPython 3.0 to"
" 3.2 releases."
msgstr ""
"CPython 2.6 和2.7 的功能已经达到平价。我们不针对任何旧的 CPython 版本。对于CPython 3.3 到 "
"3.8，也已经达到了平价。我们不针对旧的、几乎没有使用过的 CPython 3.0 到 3.2 版本。"

#: ../../Nuitka-main/Developer_Manual.rst:35
msgid ""
"This milestone was reached. Dropping support for Python 2.6 and 3.3 is an"
" option, should this prove to be any benefit. Currently it is not, as it "
"extends the test coverage only."
msgstr "这个里程碑已经达成。放弃对 Python 2.6 和 3.3 的支持是一种选择，如果这被证明有任何好处的话。目前还没有，因为它只扩展了测试范围。"

#: ../../Nuitka-main/Developer_Manual.rst:39
msgid ""
"Create the most efficient native code from this. This means to be fast "
"with the basic Python object handling."
msgstr "从中创建最有效的本地代码。这意味着要在基本的 Python 对象处理方面做到快速。"

#: ../../Nuitka-main/Developer_Manual.rst:42
msgid ""
"This milestone was reached, although of course, micro optimizations to "
"this are happening all the time."
msgstr "这个里程碑已经达成，当然，对此的微观优化一直在进行。"

#: ../../Nuitka-main/Developer_Manual.rst:45
msgid ""
"Then do constant propagation, determine as many values and useful "
"constraints as possible at compile time and create more efficient code."
msgstr "然后做 constant 传播，在编译时确定尽可能多的值和有用的约束，并创建更有效的代码。"

#: ../../Nuitka-main/Developer_Manual.rst:49
msgid ""
"This milestone is considered almost reached. We continue to discover new "
"things, but the infrastructure is there, and these are easy to add."
msgstr "这个里程碑被认为几乎达到了。我们继续发现新的东西，但基础设施已经存在，这些都很容易添加。"

#: ../../Nuitka-main/Developer_Manual.rst:53
msgid ""
"Type inference, detect and special case the handling of strings, "
"integers, lists in the program."
msgstr "类型推理，检测和特例处理程序中的字符串、整数、列表。"

#: ../../Nuitka-main/Developer_Manual.rst:56
msgid "This milestone is considered in progress."
msgstr "这个里程碑被认为是正在进行中。"

#: ../../Nuitka-main/Developer_Manual.rst:58
msgid ""
"Add interfacing to C code, so Nuitka can turn a ``ctypes`` binding into "
"an efficient binding as written with C."
msgstr "增加与 C 代码的接口，所以 Nuitka 可以把 ``ctypes`` 的绑定变成用 C 编写的有效绑定。"

#: ../../Nuitka-main/Developer_Manual.rst:61
#: ../../Nuitka-main/Developer_Manual.rst:66
msgid "This milestone is planned only."
msgstr "这个里程碑只是计划中的。"

#: ../../Nuitka-main/Developer_Manual.rst:63
msgid ""
"Add hints module with a useful Python implementation that the compiler "
"can use to learn about types from the programmer."
msgstr "增加提示模块，有一个有用的 Python 实现，编译器可以用它来向程序员学习类型。"

#: ../../Nuitka-main/Developer_Manual.rst:70
msgid "Version Numbers"
msgstr "版本数字"

#: ../../Nuitka-main/Developer_Manual.rst:72
msgid ""
"For Nuitka we use a defensive version numbering system to indicate that "
"it is not yet ready for everything. We have defined milestones and the "
"version numbers should express which of these, we consider done."
msgstr "对于 Nuitka，我们使用了一个防御性的版本编号系统，以表明它还没有准备好一切。我们已经定义了里程碑，版本号应该表达其中哪些，我们认为已经完成了。"

#: ../../Nuitka-main/Developer_Manual.rst:76
msgid "So far:"
msgstr "到目前为止："

#: ../../Nuitka-main/Developer_Manual.rst:78
msgid ""
"Before milestone 1, we used ``0.1.x`` version numbers. After reaching it,"
" we used ``0.2.x`` version numbers."
msgstr "在里程碑 1 之前，我们使用 ``0.1.x`` 的版本号。达到之后，我们使用 ``0.2.x`` 的版本号。"

#: ../../Nuitka-main/Developer_Manual.rst:81
msgid ""
"Before milestone 2 and 3, we used ``0.3.x`` version numbers. After almost"
" reaching 3, and beginning with 4, we use \"0.4.x\" version numbers. Due "
"to an interface change, ``0.5.x`` version numbers are being used."
msgstr ""
"在里程碑 2 和 3 之前，我们使用 ``0.3.x`` 的版本号。在几乎达到 3 之后，从 4 开始，我们使用 \"0.4.x\" "
"的版本号。由于接口的改变，正在使用 ``0.5.x`` 的版本号。"

#: ../../Nuitka-main/Developer_Manual.rst:86
msgid ""
"Due to reaching type inference in code generation, even if only starting,"
" the ``0.6.x`` version numbers were started to be used. This stage should"
" allow quick progress in performance for individual releases."
msgstr "由于在代码生成中达到了类型推理，即使只是开始，也开始使用 ``0.6.x`` 的版本号了。这个阶段应该允许个别版本的性能快速进步。"

#: ../../Nuitka-main/Developer_Manual.rst:91
msgid "Future:"
msgstr "未来："

#: ../../Nuitka-main/Developer_Manual.rst:93
msgid "With ``ctypes`` bindings in a usable state it will be ``0.7.x``."
msgstr "在 ``ctypes`` 绑定处于可用状态时，它将是 ``0.7.x``。"

#: ../../Nuitka-main/Developer_Manual.rst:95
msgid "Final:"
msgstr "最终："

#: ../../Nuitka-main/Developer_Manual.rst:97
msgid ""
"We will then round it up and call it Nuitka ``1.0`` when this works as "
"expected for a bunch of people. The plan is to reach this goal during "
"2021. This is based on positive assumptions that may not hold up though."
msgstr ""
"然后我们将把它围起来，当这对一群人来说如预期的那样工作时，就称之为Nuitka ``1.0``。计划是在 2021 "
"年期间达到这个目标。这是基于积极的假设，但可能不成立。"

#: ../../Nuitka-main/Developer_Manual.rst:102
msgid "Of course, all of this may be subject to change."
msgstr "当然，所有这些都可能会有变化。"

#: ../../Nuitka-main/Developer_Manual.rst:106
msgid "Current State"
msgstr "当前状态"

#: ../../Nuitka-main/Developer_Manual.rst:108
msgid "Nuitka top level works like this:"
msgstr "Nuitka 顶层的工作是这样的："

#: ../../Nuitka-main/Developer_Manual.rst:110
msgid "``nuitka.tree.Building`` outputs node tree"
msgstr "``nuitka.tree.Building`` 输出节点树"

#: ../../Nuitka-main/Developer_Manual.rst:112
msgid "``nuitka.optimization`` enhances it as best as it can"
msgstr "``nuitka.optimization`` 尽可能地增强它"

#: ../../Nuitka-main/Developer_Manual.rst:114
msgid "``nuitka.finalization`` prepares the tree for code generation"
msgstr "``nuitka.finalization`` 为代码生成准备好树"

#: ../../Nuitka-main/Developer_Manual.rst:116
msgid ""
"``nuitka.codegen.CodeGeneration`` orchestrates the creation of code "
"snippets"
msgstr "``nuitka.codegen.CodeGeneration`` 协调代码片断的创建"

#: ../../Nuitka-main/Developer_Manual.rst:119
msgid "``nuitka.codegen.*Codes`` knows how specific code kinds are created"
msgstr "``nuitka.codegen.*Codes`` 知道具体的代码种类是如何产生的"

#: ../../Nuitka-main/Developer_Manual.rst:121
msgid "``nuitka.MainControl`` keeps it all together"
msgstr "``nuitka.MainControl`` 保持一致"

#: ../../Nuitka-main/Developer_Manual.rst:123
msgid "This design is intended to last."
msgstr "这种设计的目的是为了持久。"

#: ../../Nuitka-main/Developer_Manual.rst:125
msgid "Regarding types, the state is:"
msgstr "关于类型，状态是："

#: ../../Nuitka-main/Developer_Manual.rst:127
msgid ""
"Types are always ``PyObject *``, and only a few C types, e.g. "
"``nuitka_bool`` and ``nuitka_void`` and more are coming. Even for "
"objects, often it's know that things are e.g. really a ``PyTupleObject "
"**``, but no C type is available for that yet."
msgstr ""
"类型总是 ``PyObject *``，只有少数 C 类型，例如 ``nuitka_bool`` 和 "
"``nuitka_void``，更多的类型正在到来。即使是对象，也经常知道事物是例如 ``PyTupleObject **``，但还没有 C "
"类型可用于此。"

#: ../../Nuitka-main/Developer_Manual.rst:132
msgid ""
"There are a some specific use of types beyond \"compile time constant\", "
"that are encoded in type and value shapes, which can be used to predict "
"some operations, conditions, etc. if they raise, and result types they "
"give."
msgstr ""
"有一些特定的使用类型超越了 "
"\"编译时间常量\"，这些类型在类型和值的形状中被编码，可以用来预测一些操作、条件等，如果他们提出，以及他们给出的结果类型。"

#: ../../Nuitka-main/Developer_Manual.rst:137
msgid ""
"In code generation, the supported C types are used, and sometimes we have"
" specialized code generation, e.g. a binary operation that takes an "
"``int`` and a ``float`` and produces a ``float`` value. There will be "
"fallbacks to less specific types."
msgstr ""
"在代码生成中，使用支持的 C 类型，有时我们会有专门的代码生成，例如，一个二进制操作需要一个 ``int`` 和一个 ``float`` "
"并产生一个 ``float`` 值。将会有回落到不太具体的类型。"

#: ../../Nuitka-main/Developer_Manual.rst:142
msgid ""
"The expansion with more C types is currently in progress, and there will "
"also be alternative C types, where e.g. ``PyObject *`` and ``C long`` are"
" in an enum that indicates which value is valid, and where special code "
"will be available that can avoid creating the ``PyObject **`` unless the "
"later overflows."
msgstr ""
"目前正在用更多的 C 类型进行扩展，也会有替代的 C 类型，例如 ``PyObject *`` 和 ``C long`` "
"在一个枚举中，表明哪个值是有效的，而且会有特殊的代码，可以避免创建 ``PyObject **``，除非后来的溢出。"

#: ../../Nuitka-main/Developer_Manual.rst:150
msgid "Setting up the Development Environment for Nuitka"
msgstr "为 Nuitka 设置开发环境"

#: ../../Nuitka-main/Developer_Manual.rst:152
msgid ""
"Currently there are very different kinds of files that we need support "
"for. This is best addressed with an IDE. We cover here how to setup the "
"most common one."
msgstr "目前，我们需要支持极其不同种类的文件。这一点最好用 IDE 来解决。我们在这里介绍如何设置最常见的文件。"

#: ../../Nuitka-main/Developer_Manual.rst:157
msgid "Visual Studio Code"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:159
msgid ""
"Download Visual Studio Code from here: "
"https://code.visualstudio.com/download"
msgstr "从这里下载 Visual Studio Code：https://code.visualstudio.com/download"

#: ../../Nuitka-main/Developer_Manual.rst:162
msgid ""
"At this time, this is the recommended IDE for Linux and Windows. This is "
"going to cover the plugins to install. Configuration is part of the "
"``.vscode`` in your Nuitka checkout. If you are not familiar with "
"Eclipse, this is Free Software IDE,designed to be universally extended, "
"and it truly is. There are plugins available for nearly everything."
msgstr ""
"目前，这是推荐用于 Linux 和 Windows 的 IDE。这将涵盖要安装的插件。配置是你的 Nuitka 检出中的 ``.vscode`` "
"的一部分。如果你不熟悉 Eclipse，这是一个自由软件 IDE，被设计成可以普遍扩展的，而且它确实如此。几乎所有的东西都有插件可用。"

#: ../../Nuitka-main/Developer_Manual.rst:168
msgid ""
"The extensions to be installed are part of the Visual Code "
"recommendations in ``.vscode/extensions.json`` and you will be prompted "
"about that and ought to install these."
msgstr ""
"要安装的扩展是 Visual Code 建议的一部分，在 ``.vscode/extensions.json`` "
"中，你会被提示到这一点，应该安装这些。"

#: ../../Nuitka-main/Developer_Manual.rst:173
msgid "Eclipse / PyCharm"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:175
msgid ""
"Don't use these anymore, we consider Visual Studio Code to be far "
"superior for delivering a nice out of the box environment."
msgstr "不要再使用这些了，我们认为 Visual Studio Code 在提供一个良好的开箱即用环境方面要优越得多。"

#: ../../Nuitka-main/Developer_Manual.rst:180
msgid "Commit and Code Hygiene"
msgstr "承诺和守则的卫士"

#: ../../Nuitka-main/Developer_Manual.rst:182
msgid ""
"In Nuitka we have tools to autoformat code, you can execute them "
"manually, but it's probably best to execute them at commit time, to make "
"sure when we share code, it's already well format, and to avoid noise "
"doing cleanups."
msgstr ""
"在 Nuitka "
"中，我们有自动格式化代码的工具，你可以手动执行，但最好是在提交时执行，以确保当我们分享代码时，它已经被很好地格式化了，并避免做清理的噪音。"

#: ../../Nuitka-main/Developer_Manual.rst:187
msgid ""
"The kinds of changes also often cause unnecessary merge conflicts, while "
"the autoformat is designed to format code also in a way that it avoids "
"merge conflicts in the normal case, e.g. by doing imports one item per "
"line."
msgstr "这类修改也经常引起不必要的合并冲突，而自动格式化的设计也是为了在正常情况下避免合并冲突，比如说每行做导入一项，就可以避免合并冲突。"

#: ../../Nuitka-main/Developer_Manual.rst:192
msgid "In order to set up hooks, you need to execute these commands:"
msgstr "为了设置钩子，你需要执行这些命令："

#: ../../Nuitka-main/Developer_Manual.rst:201
msgid ""
"These commands will make sure that the ``autoformat-nuitka-source`` is "
"run on every staged file content at the time you do the commit. For C "
"files, it may complain unavailability of ``clang-format``, follow it's "
"advice. You may call the above tool at all times, without arguments to "
"format call Nuitka source code."
msgstr ""
"这些命令将确保 ``autoformat-nuitka-source`` 在你做提交的时候对每个阶段性的文件内容运行。对于 C 文件，它可能会抱怨"
" ``clang-format`` 不可用，请遵循它的建议。你可以在任何时候调用上述工具，不需要参数就可以格式化调用 Nuitka 源代码。"

#: ../../Nuitka-main/Developer_Manual.rst:207
msgid ""
"Should you encounter problems with applying the changes to the checked "
"out file, you can always execute it with ``COMMIT_UNCHECKED=1`` "
"environment set."
msgstr "如果你在将修改应用到检查出来的文件时遇到问题，你总是可以在 ``COMMIT_UNCHECKED=1`` 的环境设置下执行它。"

#: ../../Nuitka-main/Developer_Manual.rst:213
msgid "Coding Rules Python"
msgstr "Python 编码规则"

#: ../../Nuitka-main/Developer_Manual.rst:215
msgid ""
"These rules should generally be adhered when working on Nuitka code. It's"
" not library code and it's optimized for readability, and avoids all "
"performance optimization for itself."
msgstr "在 Nuitka 代码上工作时，一般应遵守这些规则。它不是库的代码，而且它是为了可读性而优化的，避免了对自己的所有性能优化。"

#: ../../Nuitka-main/Developer_Manual.rst:220
msgid "Tool to format"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:222
msgid ""
"There is a tool ``bin/autoformat-nuitka-source`` which is to apply "
"automatic formatting to code as much as possible. It uses ``black`` "
"(internally) for consistent code formatting. The imports are sorted with "
"``isort`` for proper order."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:227
msgid ""
"The tool (mostly ``black`` and ``isort``) encodes all formatting rules, "
"and makes the decisions for us. The idea being that we can focus on "
"actual code and do not have to care as much about other things. It also "
"deals with Windows new lines, trailing space, etc. and even sorts pylint "
"disable statements."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:234
msgid "Identifiers"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:236
msgid ""
"Classes are camel case with leading upper case. Functions and methods are"
" with leading verb in lower case, but also camel case. Variables and "
"arguments are lower case with ``_`` as a separator."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:246
msgid ""
"Base classes that are abstract have their name end with ``Base``, so that"
" a meta class can use that convention, and readers immediately know, that"
" it will not be instantiated like that."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:250
msgid ""
"Function calls use keyword argument preferably. These are slower in "
"CPython, but more readable:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:259
msgid "When the names don't add much value, sequential calls can be done:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:265
msgid ""
"Here, ``setLoopContinueTarget`` will be so well known that the reader is "
"expected to know the argument names and their meaning, but it would be "
"still better to add them. But in this instance, the variable name already"
" indicates that it is."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:271
msgid "Module/Package Names"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:273
msgid ""
"Normal modules are named in camel case with leading upper case, because "
"of their role as singleton classes. The difference between a module and a"
" class is small enough and in the source code they are also used "
"similarly."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:278
msgid ""
"For the packages, no real code is allowed in their ``__init__.py`` and "
"they must be lower case, like e.g. ``nuitka`` or ``codegen``. This is to "
"distinguish them from the modules."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:282
msgid ""
"Packages shall only be used to group things. In ``nuitka.codegen`` the "
"code generation packages are located, while the main interface is "
"``nuitka.codegen.CodeGeneration`` and may then use most of the entries as"
" local imports."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:287
msgid ""
"There is no code in packages themselves. For programs, we use "
"``__main__`` package to carry the actual code."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:290
msgid ""
"Names of modules should be plurals if they contain classes. Example is "
"that a ``Nodes`` module that contains a ``Node`` class."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:294
msgid "Names for context manages start with ``with``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:296
msgid ""
"In order to easily recognize that something is to be used as a context "
"manager, we follow a pattern of naming them ``withSomething``, to make "
"that easily recognized."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:306
msgid "This makes these easy to recognize even in their definition."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:309
msgid "Prefer list contractions over built-ins"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:311
msgid ""
"This concerns ``map``, ``filter``, and ``apply``. Usage of these built-"
"ins is highly discouraged within Nuitka source code. Using them is "
"considered worth a warning by \"PyLint\" e.g. \"Used built-in function "
"'map'\". We should use list contractions instead, because they are more "
"readable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:317
msgid ""
"List contractions are a generalization for all of them. We love "
"readability and with Nuitka as a compiler, there won't be any performance"
" difference at all."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:321
msgid ""
"There are cases where a list contraction is faster because you can avoid "
"to make a function call. And there may be cases, where map is faster, if "
"a function must be called. These calls can be very expensive in CPython, "
"and if you introduce a function, just for ``map``, then it might be "
"slower."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:327
msgid ""
"But of course, Nuitka is the project to free us from what is faster and "
"to allow us to use what is more readable, so whatever is faster, we don't"
" care. We make all options equally fast and let people choose."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:331
msgid ""
"For Nuitka the choice is list contractions as these are more easily "
"changed and readable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:334
msgid "Look at this code examples from Python:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:353
msgid ""
"This pretty much is what makes properties bad. One would hope ``B().x`` "
"to be ``2``, but instead it's not changed. Because of the way properties "
"take the functions and not members, and because they then are not part of"
" the class, they cannot be overloaded without re-declaring them."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:358
msgid ""
"Overloading is then not at all obvious anymore. Now imagine having a "
"setter and only overloading the getter. How to update the property "
"easily?"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:362
msgid ""
"So, that's not likable about them. And then we are also for clarity in "
"these internal APIs too. Properties try and hide the fact that code needs"
" to run and may do things. So let's not use them."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:366
msgid ""
"For an external API you may exactly want to hide things, but internally "
"that has no use, and in Nuitka, every API is internal API. One exception "
"may be the ``hints`` module, which will gladly use such tricks for an "
"easier write syntax."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:373
msgid "Coding Rules C"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:375
msgid ""
"For the static C parts, e.g. compiled types, helper codes, the ``clang-"
"format`` from LLVM project is used, the tool ``autoformat-nuitka-source``"
" does this for us."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:379
msgid ""
"We always have blocks for conditional statements to avoid typical "
"mistakes made by adding a statement to a branch, forgetting to make it a "
"block."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:385
msgid "The \"git flow\" model"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:387
msgid "The flow is used for releases and occasionally subsequent hot fixes."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:389
msgid ""
"A few feature branches were used so far. It allows for quick delivery of "
"fixes to both the stable and the development version, supported by a git "
"plug-in, that can be installed via \"apt-get install git-flow\"."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:393
msgid "Stable (``main`` branch)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:395
msgid ""
"The stable version, is expected to pass all the tests at all times and is"
" fully supported. As soon as bugs are discovered, they are fixed as hot "
"fixes, and then merged to develop by the \"git flow\" automatically."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:400
msgid "Development (``develop`` branch)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:402
msgid ""
"The future release, supposedly in almost ready for release state at "
"nearly all times, but this is as strict. It is not officially supported, "
"and may have problems and at times inconsistencies. Normally this branch "
"is supposed to not be rebased. For severe problems it may be done though."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:408
msgid "Factory (default feature branch)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:410
msgid ""
"Code under construction. We publish commits there, that may not hold up "
"in testing, and before it enters develop branch. Factory may have severe "
"regressions frequently, and commits become **rebased all the time**, so "
"do not base your patches on it, please prefer the ``develop`` branch for "
"that, unless of course, it's about factory code itself."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:417
msgid "Personal branches (jorj, orsiris, others as well)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:419
msgid "We are currently not using this, but it's an option."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:421
msgid "Feature Branches"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:423
msgid ""
"We are not currently using these. They could be used for long lived "
"changes that extend for multiple release cycles and are not ready yet. "
"Currently we perform all changes in steps that can be included in "
"releases or delay making those changes."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:430
msgid "Nuitka \"git/github\" Workflow"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:432
msgid "Forking and cloning"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:434
msgid ""
"You need to have git installed and GitHub account. Goto Nuitka repository"
" <https://github.com/Nuitka/Nuitka> and fork the repository."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:438
msgid "To clone it to your local machine execute the following your git bash:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:447
msgid "Create a Branch"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:455
msgid ""
"If you are having merge conflicts while doing the previous step, then "
"check out (DON'T FORGET TO SAVE YOUR CHANGES FIRST IF ANY): "
"<https://stackoverflow.com/questions/1125968/how-do-i-force-git-pull-to-"
"overwrite-local-files>"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:459
msgid "In case you have an existing branch rebase it to develop"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:466
msgid "Fix the merge conflicts if any, stash them and continue:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:472
msgid "If anything goes wrong while rebasing:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:478
msgid "Making changes"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:488
msgid "API Documentation and Guidelines"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:490
msgid ""
"There is API documentation generated with ``doxygen``, available at `this"
" location <https://nuitka.net/apidoc>`__ ."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:493
msgid ""
"To ensure meaningful ``doxygen`` output, the following guidelines must be"
" observed when creating or updating Python source:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:497
msgid "Use of Standard Python ``__doc__`` Strings"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:499
msgid ""
"Every class and every method should be documented via the standard Python"
" delimiters (``\"\"\" ... \"\"\"``) in the usual way."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:503
msgid "Special ``doxygen`` Anatomy of ``__doc__``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:507
msgid "We are replacing doxygen with sphinx, this is all obsolete"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:509
msgid ""
"Immediately after the leading ``\"\"\"``, and after 1 space on the same "
"line, enter a brief description or title of the class or method. This "
"must be 1 line and be followed by at least 1 empty line."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:513
msgid ""
"Depending on the item, choose from the following \"sections\" to describe"
" what the item is and does."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:516
msgid ""
"Each section name is coded on its own line, aligned with the leading "
"``\"\"\"`` and followed by a colon \":\". Anything following the section,"
" must start on a new line and be indented by 4 spaces relative to the "
"section. Except for the first section (``Notes:``) after the title, "
"sections need not be preceded by empty lines -- but it is good practice "
"to still do that."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:523
msgid "``Notes:`` detailed description of the item, any length."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:525
msgid ""
"May contain line breaks with each new line starting aligned with previous"
" one. The text will automatically be joined across line breaks and be "
"reformatted in the browser."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:529
msgid ""
"If you describe details for a class, you can do so **without** using this"
" section header and all formatting will still work fine. If you however "
"omit the ``Notes:`` for methods, then the text will be interpreted **as "
"code**, be shown in an ugly monospaced font, and no automatic line breaks"
" will occur in the browser."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:535
msgid "``Args:`` positional arguments."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:537
msgid ""
"Each argument then follows, starting on a new line and indented by 4 "
"spaces. The argument name must be followed by a colon ``:`` or double "
"hash ``--``, followed by a description of arbitrary length."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:541
msgid "The description can be separated by line breaks."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:543
msgid "``Kwargs:`` keyword arguments. Same rules as for args."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:545
msgid ""
"``Returns:`` description of what will be returned if applicable (any "
"length)."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:548
msgid "``Yields:`` synonymous for ``Returns:``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:550
msgid "``Raises:`` name any exceptions that may be raised."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:552
msgid "``Examples:`` specify any example code."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:584
msgid "Checking the Source"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:586
msgid ""
"The static checking for errors is currently done with ``PyLint``. In the "
"future, Nuitka itself will gain the ability to present its findings in a "
"similar way, but this is not a priority, and we are not there yet."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:590
msgid "So, we currently use ``PyLint`` with options defined in a script."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:596
msgid ""
"The above command is expected to give no warnings. It is also run on our "
"CI and we will not merge branches that do not pass."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:601
msgid "Running the Tests"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:603
msgid "This section describes how to run Nuitka tests."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:606
msgid "Running all Tests"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:608
msgid "The top level access to the tests is as simple as this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:614
msgid "For fine grained control, it has the following options:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:708
msgid ""
"You will only run the CPython test suites, if you have the submodules of "
"the Nuitka git repository checked out. Otherwise, these will be skipped "
"with a warning that they are not available."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:712
msgid ""
"The policy is generally, that ``./test/run-tests`` running and passing "
"all the tests on Linux and Windows shall be considered sufficient for a "
"release, but of course, depending on changes going on, that might have to"
" be expanded."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:718
msgid "Basic Tests"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:720
msgid "You can run the \"basic\" tests like this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:726
msgid ""
"These tests normally give sufficient coverage to assume that a change is "
"correct, if these \"basic\" tests pass. The most important constructs and"
" built-ins are exercised."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:730
msgid ""
"To control the Python version used for testing, you can set the "
"``PYTHON`` environment variable to e.g. ``python3.5`` (can also be full "
"path), or simply execute the ``run_all.py`` script directly with the "
"intended version, as it is portable across all supported Python versions,"
" and defaults testing with the Python version is run with."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:737
msgid "Syntax Tests"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:739
msgid ""
"Then there are \"syntax\" tests, i.e. language constructs that need to "
"give a syntax error."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:742
msgid ""
"It sometimes so happens that Nuitka must do this itself, because the "
"``ast.parse`` doesn't see the problem and raises no ``SyntaxError`` of "
"its own. These cases are then covered by tests to make sure they work as "
"expected."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:747
msgid ""
"Using the ``global`` statement on a function argument is an example of "
"this. These tests make sure that the errors of Nuitka and CPython are "
"totally the same for this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:756
msgid "Program Tests"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:758
msgid ""
"Then there are small \"programs\" tests, that e.g. exercise many kinds of"
" import tricks and are designed to reveal problems with inter-module "
"behavior. These can be run like this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:767
msgid "Generated Tests"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:769
msgid ""
"There are tests, which are generated from Jinja2 templates. They aim at "
"e.g. combining at types with operations, in-place or not, or large "
"constants. These can be run like this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:778
msgid "Compile Nuitka with Nuitka"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:780
msgid ""
"And there is the \"compile itself\" or \"reflected\" test. This test "
"makes Nuitka compile itself and compare the resulting C++ when running "
"compiled to non-compiled, which helps to find in-determinism."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:784
msgid ""
"The test compiles every module of Nuitka into an extension module and all"
" of Nuitka into a single binary."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:787
msgid ""
"That test case also gives good coverage of the ``import`` mechanisms, "
"because Nuitka uses a lot of packages and imports between them."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:796
msgid "Internal/Plugin API"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:798
msgid ""
"The documentation from the source code for both the Python and the C "
"parts are published as `Nuitka API <https://nuitka.net/apidoc>`__ and "
"argumently in a relatively bad shape as we started generating those with "
"Doxygen only relatively late."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:808
msgid ""
"Improvements have already been implemented for plugins: The plugin base "
"class defined in ``PluginBase.py`` (which is used as a template for all "
"plugins) is fully documented in Doxygen now. The same is true for the "
"recently added standard plugins ``NumpyPlugin.py`` and "
"``TkinterPlugin.py``. These will be uploaded very soon."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:814
msgid "Going forward, this will also happen for the remaining standard plugins."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:816
msgid ""
"Please find `here <https://github.com/Nuitka/Nuitka/blob/develop"
"/UserPlugin-Creation.rst>`__ a detailed description of how to write your "
"own plugin."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:820
msgid ""
"To learn about plugin option specification consult `this document "
"<https://github.com/Nuitka/Nuitka/blob/develop/Using-Plugin-"
"Options.rst>`__."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:825
msgid "Working with the CPython suites"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:827
msgid ""
"The CPython test suites are different branches of the same submodule. "
"When you update your git checkout, they will frequently become detached. "
"In this case, simply execute this command:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:836
msgid "When adding a test suite, for a new version, proceed like this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:892
msgid "Design Descriptions"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:894
msgid ""
"These should be a lot more and contain graphics from presentations given."
" It will be filled in, but not now."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:900
msgid ""
"The logo was submitted by \"dr. Equivalent\". It's source is contained in"
" ``doc/Logo`` where 3 variants of the logo in SVG are placed."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:903
msgid "Symbol only (symbol)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:910
msgid "Text next to symbol (horizontal)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:917
msgid "Text beneath symbol (vertical)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:924
msgid "From these logos, PNG images, and \"favicons\", and are derived."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:926
msgid ""
"The exact ImageMagick commands are in "
"``nuitka/tools/release/Documentation``, but are not executed each time, "
"the commands are also replicated here:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:941
msgid "Choice of the Target Language"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:943
msgid "Choosing the target language was important decision. factors were:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:945
msgid "The portability of Nuitka is decided here"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:946
msgid "How difficult is it to generate the code?"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:947
msgid "Does the Python C-API have bindings?"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:948
msgid "Is that language known?"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:949
msgid "Does the language aid to find bugs?"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:951
msgid ""
"The *decision for C11* is ultimately one for portability, general "
"knowledge of the language and for control over created code, e.g. being "
"able to edit and try that quickly."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:955
msgid ""
"The current status is to use pure C11. All code compiles as C11, and also"
" in terms of workaround to missing compiler support as C++03. This is "
"mostly needed, because MSVC does not support C. Naturally we are not "
"using any C++ features, just the allowances of C++ features that made it "
"into C11, which is e.g. allowing late definitions of variables."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:962
msgid "Use of Scons internally"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:964
msgid ""
"Nuitka does not involve Scons in its user interface at all; Scons is "
"purely used internally. Nuitka itself, being pure Python, will run "
"without any build process just fine."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:968
msgid ""
"Nuitka simply prepares ``<program>.build`` folders with lots of files and"
" tasks scons to execute the final build, after which Nuitka again will "
"take control and do more work as necessary."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:974
msgid ""
"When we speak of \"standalone\" mode, this is handled outside of Scons, "
"and after it, creating the \".dist\" folder. This is done in "
"``nuitka.MainControl`` module."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:978
msgid ""
"For interfacing to Scons, there is the module "
"``nuitka.build.SconsInterface`` that will support calling ``scons`` - "
"potentially from one of two inline copies (one for before / one for "
"Python 3.5 or later). These are mainly used on Windows or when using "
"source releases - and passing arguments to it. These arguments are passed"
" as ``key=value``, and decoded in the scons file of Nuitka."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:985
msgid ""
"The scons file is named ``SingleExe.scons`` for lack of better name. It's"
" really wrong now, but we have yet to find a better name. It once "
"expressed the intention to be used to create executables, but the same "
"works for modules too, as in terms of building, and to Scons, things "
"really are the same."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:991
msgid ""
"The scons file supports operation in multiple modes for many things, and "
"modules is just one of them. It runs outside of Nuitka process scope, "
"even with a different Python version potentially, so all the information "
"must be passed on the command line."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:996
msgid ""
"What follows is the (lengthy) list of arguments that the scons file "
"processes:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:999
msgid "``source_dir``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1001
msgid ""
"Where is the generated C source code. Scons will just compile everything "
"it finds there. No list of files is passed, but instead this directory is"
" being scanned."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1005
msgid "``nuitka_src``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1007
msgid ""
"Where do the include files and static C parts of Nuitka live. These "
"provide e.g. the implementation of compiled function, generators, and "
"other helper codes, this will point to where ``nuitka.build`` package "
"lives normally."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1012
msgid "``module_mode``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1014
msgid "Build a module instead of a program."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1016
msgid "``result_base``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1018
msgid ""
"This is not a full name, merely the basename for the result to be "
"produced, but with path included, and the suffix comes from module or "
"executable mode."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1022
msgid "``debug_mode``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1024
msgid ""
"Enable debug mode, which is a mode, where Nuitka tries to help identify "
"errors in itself, and will generate less optimal code. This also asks for"
" warnings, and makes the build fail if there are any. Scons will pass "
"different compiler options in this case."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1029
msgid "``python_debug``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1031
msgid ""
"Compile and link against Python debug mode, which does assertions and "
"extra checks, to identify errors, mostly related to reference counting. "
"May make the build fail, if no debug build library of CPython is "
"available. On Windows it is possible to install it for CPython3.5 or "
"higher."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1037
msgid "``full_compat_mode``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1039
msgid ""
"Full compatibility, even where it's stupid, i.e. do not provide "
"information, even if available, in order to assert maximum compatibility."
" Intended to control the level of compatibility to absurd."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1044
msgid "``experimental_mode``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1046
msgid "Do things that are not yet accepted to be safe."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1048
msgid "``lto_mode``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1050
msgid ""
"Make use of link time optimization of gcc compiler if available and known"
" good with the compiler in question. So far, this was not found to make "
"major differences."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1054
msgid "``disable_console``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1056
msgid "Windows subsystem mode: Disable console for windows builds."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1058
msgid "``unstriped_mode``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1060
msgid "Unstriped mode: Do not remove debug symbols."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1062
msgid "``clang_mode``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1064
msgid "Clang compiler mode, default on macOS X and FreeBSD, optional on Linux."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1067
msgid "``mingw_mode``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1069
msgid "MinGW compiler mode, optional and useful on Windows only."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1071
msgid "``standalone_mode``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1073
msgid "Building a standalone distribution for the binary."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1075
msgid "``show_scons``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1077
msgid ""
"Show scons mode, output information about Scons operation. This will e.g."
" also output the actual compiler used, output from compilation process, "
"and generally debug information relating to be build process."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1082
msgid "``python_prefix``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1084
msgid ""
"Home of Python to be compiled against, used to locate headers and "
"libraries."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1087
msgid "``target_arch``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1089
msgid "Target architecture to build. Only meaningful on Windows."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1091
msgid "``python_version``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1093
msgid "The major version of Python built against."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1095
msgid "``abiflags``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1097
msgid ""
"The flags needed for the Python ABI chosen. Might be necessary to find "
"the folders for Python installations on some systems."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1100
msgid "``icon_path``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1102
msgid "The icon to use for Windows programs if given."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1105
msgid "Locating Modules and Packages"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1107
msgid ""
"The search for modules used is driven by ``nuitka.importing.Importing`` "
"module."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1110
msgid "Quoting the ``nuitka.importing.Importing`` documentation:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1112
msgid "Locating modules and package source on disk."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1114
msgid ""
"The actual import of a module would already execute code that changes "
"things. Imagine a module that does ``os.system()``, it would be done "
"during compilation. People often connect to databases, and these kind of "
"things, at import time."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1119
msgid ""
"Therefore CPython exhibits the interfaces in an ``imp`` module in "
"standard library, which one can use those to know ahead of time, what "
"file import would load. For us unfortunately there is nothing in CPython "
"that is easily accessible and gives us this functionality for packages "
"and search paths exactly like CPython does, so we implement here a multi "
"step search process that is compatible."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1126
msgid ""
"This approach is much safer of course and there is no loss. To determine "
"if it's from the standard library, one can abuse the attribute "
"``__file__`` of the ``os`` module like it's done in "
"``isStandardLibraryPath`` of this module."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1131
msgid "End quoting the ``nuitka.importing.Importing`` documentation."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1133
msgid "Role"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1135
msgid ""
"This module serves the recursion into modules and analysis if a module is"
" a known one. It will give warnings for modules attempted to be located, "
"but not found. These warnings are controlled by a while list inside the "
"module."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1140
msgid ""
"The decision making and caching are located in the ``nuitka.tree`` "
"package, in modules ``nuitka.tree.Recursion`` and "
"``nuitka.tree.ImportCache``. Each module is only considered once (then "
"cached), and we need to obey lots of user choices, e.g. to compile a "
"standard library or not."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1147
msgid "Hooking for module ``import`` process"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1149
msgid ""
"Currently, in generated code, for every ``import`` a normal "
"``__import__()`` built-in call is executed. The "
"``nuitka/build/static_src/MetaPathBasedLoader.c`` file provides the "
"implementation of a ``sys.meta_path`` hook."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1154
msgid ""
"This meta path based importer allows us to have the Nuitka provided "
"module imported even when imported by non-compiled code."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1159
msgid ""
"Of course, it would make sense to compile time detect which module it is "
"that is being imported and then to make it directly. At this time, we "
"don't have this inter-module optimization yet, mid-term it should become "
"easy to add."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1165
msgid "Supporting ``__class__`` of Python3"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1167
msgid ""
"In Python3 the handling of ``__class__`` and ``super`` is different from "
"Python2. It used to be a normal variable, and now the following things "
"have changed."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1171
msgid ""
"The use of the ``super`` variable name triggers the addition of a closure"
" variable ``__class__``, as can be witnessed by the following code:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1190
msgid "Output is:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1198
msgid "This value of ``__class__`` is also available in the child functions."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1200
msgid ""
"The parser marks up code objects usage of \"super\". It doesn't have to "
"be a call, it can also be a local variable. If the ``super`` built-in is "
"assigned to another name and that is used without arguments, it won't "
"work unless ``__class__`` is taken as a closure variable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1205
msgid ""
"As can be seen in the CPython3 code, the closure value is added after the"
" class creation is performed."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1208
msgid ""
"It appears, that only functions locally defined to the class are affected"
" and take the closure."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1211
msgid "This left Nuitka with the strange problem, of how to emulate that."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1213
msgid "The solution is this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1215
msgid ""
"Under Python3, usage of ``__class__`` as a reference in a child function "
"body is mandatory. It remains that way until all variable names have been"
" resolved."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1221
msgid "When recognizing calls to ``super`` without arguments, make the arguments"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1220
msgid ""
"into variable reference to ``__class__`` and potentially ``self`` "
"(actually first argument name)."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1223
msgid ""
"After all variables have been known, and no suspicious unresolved calls "
"to anything named ``super`` are down, then unused references are "
"optimized away by the normal unused closure variable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1227
msgid "Class dictionary definitions are added."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1229
msgid ""
"These are special direct function calls, ready to propagate also "
"\"bases\" and \"metaclass\" values, which need to be calculated outside."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1232
msgid ""
"The function bodies used for classes will automatically store "
"``__class__`` as a shared local variable, if anything uses it. And if "
"it's not assigned by user code, it doesn't show up in the \"locals()\" "
"used for dictionary creation."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1237
msgid ""
"Existing ``__class__`` local variable values are in fact provided as "
"closure, and overridden with the built class , but they should be used "
"for the closure giving, before the class is finished."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1241
msgid ""
"So ``__class__`` will be local variable of the class body, until the "
"class is built, then it will be the ``__class__`` itself."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1245
msgid "Frame Stack"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1247
msgid ""
"In Python, every function, class, and module has a frame. It creates "
"created when the scope is entered, and there is a stack of these at run "
"time, which becomes visible in tracebacks in case of exceptions."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1251
msgid ""
"The choice of Nuitka is to make this an explicit element of the node "
"tree, that are as such subject to optimization. In cases, where they are "
"not needed, they may be removed."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1255
msgid "Consider the following code."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1265
msgid ""
"In this example, the frame is not needed for all the code, because the "
"condition checked wouldn't possibly raise at all. The idea is the make "
"the frame guard explicit and then to reduce its scope whenever possible."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1269
msgid "So we start out with code like this one:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1280
msgid "This is to be optimized into:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1291
msgid ""
"Notice how the frame guard taking is limited and may be avoided, or in "
"best cases, it might be removed completely. Also this will play a role "
"when in-lining function. The frame stack entry will then be automatically"
" preserved without extra care."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1298
msgid ""
"In the actual code, ``nuitka.nodes.FrameNodes.StatementsFrame`` is "
"represents this as a set of statements to be guarded by a frame presence."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1303
msgid "Parameter Parsing"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1305
msgid ""
"The parsing of parameters is very convoluted in Python, and doing it in a"
" compatible way is not that easy. This is a description of the required "
"process, for an easier overview."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1310
msgid "Input"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1312
msgid ""
"The input is an argument ``tuple`` (the type is fixed), which contains "
"the positional arguments, and potentially an argument ``dict`` (type is "
"fixed as well, but could also be ``NULL``, indicating that there are no "
"keyword arguments."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1318
msgid "Keyword dictionary"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1320
msgid ""
"The keyword argument dictionary is checked first. Anything in there, that"
" cannot be associated, either raise an error, or is added to a "
"potentially given star dict argument. So there are two major cases."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1324
msgid ""
"No star dict argument: Iterate over dictionary, and assign or raise "
"errors."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1327
msgid "This check covers extra arguments given."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1329
msgid ""
"With star dict argument: Iterate over dictionary, and assign or raise "
"errors."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1332
msgid ""
"Interesting case for optimization are no positional arguments, then no "
"check is needed, and the keyword argument dictionary could be used as the"
" star argument. Should it change, a copy is needed though."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1336
msgid ""
"What's noteworthy here, is that in comparison to the keywords, we can "
"hope that they are the same value as we use. The interning of strings "
"increases chances for non-compiled code to do that, esp. for short names."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1341
msgid ""
"We then can do a simple ``is`` comparison and only fall back to real "
"string ``==`` comparisons, after all of these failed. That means more "
"code, but also a lot faster code in the positive case."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1346
msgid "Argument tuple"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1348
msgid ""
"After this completed, the argument tuple is up for processing. The first "
"thing it needs to do is to check if it's too many of them, and then to "
"complain."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1352
msgid ""
"For arguments in Python2, there is the possibility of them being nested, "
"in which case they cannot be provided in the keyword dictionary, and "
"merely should get picked from the argument tuple."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1356
msgid ""
"Otherwise, the length of the argument tuple should be checked against its"
" position and if possible, values should be taken from there. If it's "
"already set (from the keyword dictionary), raise an error instead."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1361
msgid "SSA form for Nuitka"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1363
msgid ""
"The SSA form is critical to how optimization works. The so called trace "
"collections builds up traces. These are facts about how this works:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1366
msgid ""
"Assignments draw from a counter unique for the variable, which becomes "
"the variable version. This happens during tree building phase."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1370
msgid "References are associated with the version of the variable active."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1372
msgid ""
"This can be a merge of branches. Trace collection does do that and "
"provides nodes with the currently active trace for a variable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1375
msgid ""
"The data structures used for trace collection need to be relatively "
"compact as the trace information can become easily much more data than "
"the program itself."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1379
msgid "Every trace collection has these:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1381
msgid "variable_actives"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1383
msgid ""
"Dictionary, where per \"variable\" the currently used version is. Used to"
" track situations changes in branches. This is the main input for merge "
"process."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1387
msgid "variable_traces"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1389
msgid ""
"Dictionary, where \"variable\" and \"version\" form the key. The values "
"are objects with or without an assignment, and a list of usages, which "
"starts out empty."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1393
msgid ""
"These objects have usages appended to them. In \"onVariableSet\", a new "
"version is allocated, which gives a new object for the dictionary, with "
"an empty usages list, because each write starts a new version. In "
"\"onVariableUsage\" the version is detected from the current version. It "
"may be not set yet, which means, it's a read of an undefined value (local"
" variable, not a parameter name), or unknown in case of global variable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1401
msgid ""
"These objects may be told that their value has escaped. This should "
"influence the value friend they attached to the initial assignment. Each "
"usage may have a current value friend state that is different."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1405
msgid ""
"When merging branches of conditional statements, the merge shall apply as"
" follows:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1408
msgid "Branches have their own collection"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1410
msgid ""
"Thee have potentially deviating sets of ``variable_actives``. These are "
"children of an outer collections."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1413
msgid "Case a) One branch only."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1415
msgid ""
"For that branch a collection is performed. As usual new assignments "
"generate a new version making it \"active\", references then related to "
"these \"active\" versions."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1419
msgid ""
"Then, when the branch is merged, for all \"active\" variables, it is "
"considered, if that is a change related to before the branch. If it's not"
" the same, a merge trace with the branch condition is created with the "
"one active in the collection before that statement."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1424
msgid "Case b) Two branches."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1426
msgid ""
"When there are two branches, they both as are treated as above, except "
"for the merge."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1429
msgid ""
"When merging, a difference in active variables between the two branches "
"creates the merge trace."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1434
msgid ""
"For conditional expressions, there are always only two branches. Even if "
"you think you have more than one branch, you do not. It's always nested "
"branches, already when it comes out of the ``ast`` parser."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1438
msgid "Trace structure, there are different kinds of traces."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1440
msgid "Initial write of the version"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1442
msgid ""
"There may be an initial write for each version. It can only occur at the "
"start of the scope, but not later, and there is only one. This might be "
"known to be \"initialized\" (parameter variables of functions are like "
"that) or \"uninitialized\", or \"unknown\"."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1447
msgid "Merge of other one or two other versions"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1449
msgid ""
"This combines two or more previous versions. In cases of loop exits or "
"entries, there are multiple branches to combine potentially. These "
"branches can have vastly different properties."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1453
msgid "Becoming unknown."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1455
msgid ""
"When control flow escapes, e.g. for a module variable, any write can "
"occur to it, and it's value cannot be trusted to be unchanged. These are "
"then traced as unknown."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1459
msgid ""
"All traces have a base class ``ValueTraceBase`` which provides the "
"interface to query facts about the state of a variable in that trace. "
"It's e.g. of some interest, if a variable must have a value or must not. "
"This allows to e.g. omit checks, know what exceptions might raise."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1465
msgid "Loop SSA"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1467
msgid ""
"For loops we have the addition difficulty that we need would need to look"
" ahead what types a variable has at loop exit, but that is a cyclic "
"dependency."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1471
msgid ""
"Our solution is to consider the variable types at loop entry. When these "
"change, we drop all gained information from inside the loop. We may e.g. "
"think that a variable is a ``int`` or ``float``, but later recognize that"
" it can only be a float. Derivations from ``int`` must be discarded, and "
"the loop analysis restarted."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1477
msgid ""
"Then during the loop, we assign an incomplete loop trace shape to the "
"variable, which e.g. says it was an ``int`` initially and additional type"
" shapes, e.g. ``int or long`` are then derived. If at the end of the "
"loop, a type produced no new types, we know we are finished and mark the "
"trace as a complete loop trace."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1483
msgid ""
"If it is not, and next time, we have the same initial types, we add the "
"ones derived from this to the starting values, and see if this gives more"
" types."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1488
msgid "Python Slots in Optimization"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1491
msgid "Basic Slot Idea"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1493
msgid ""
"For almost all the operations in Python, a form of overloading is "
"available. That is what makes it so powerful."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1496
msgid "So when you write an expression like this one:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1502
msgid ""
"This something will not just blindly work when it's a float, but go "
"through a slot mechanism, which then can be overloaded."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1516
msgid ""
"Here it is the case, that this is used by user code, but more often this "
"is used internally. Not all types have all slots, e.g. ``list`` does not "
"have ``__float__`` and therefore will refuse an addition to a ``float`` "
"value, based on that."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1521
msgid ""
"Another slot is working here, that we didn't mention yet, and that is "
"``__add__`` which for some times will be these kinds of conversions or it"
" will not do that kind of thing, e.g. something do hard checks, which is "
"why this fails to work:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1530
msgid ""
"As a deliberate choice, there is no ``__list__`` slot used. The Python "
"designers are aiming at solving many things with slots, but they also "
"accept limitations."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1534
msgid ""
"There are many slots that are frequently used, most often behind your "
"back (``__iter__``, ``__next__``, ``__lt__``, etc.). The list is large, "
"and tends to grow with Python releases, but it is not endless."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1539
msgid "Representation in Nuitka"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1541
msgid ""
"So a slot in Nuitka typically has an owning node. We use ``__len__`` as "
"an example here. In the ``computeExpression`` the ``len`` node named "
"``ExpressionBuiltinLen`` has to defer the decision what it computes to "
"its argument."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1553
msgid ""
"That decision then, in the absence of any type knowledge, must be done "
"absolutely carefully and conservative, as could see anything executing "
"here."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1557
msgid ""
"That examples this code in ``ExpressionBase`` which every expression by "
"default uses:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1603
msgid ""
"Notice how by default, known ``__len__`` but unpredictable or even "
"unknown if a ``__len__`` slot is there, the code indicates that its "
"contents and the control flow escapes (could change things behind out "
"back) and any exception could happen."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1608
msgid ""
"Other expressions can know better, e.g. for compile time constants we can"
" be a whole lot more certain:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1620
msgid ""
"In this case, we are using a function that will produce a concrete value "
"or the exception that the ``computation`` function raised. In this case, "
"we can let the Python interpreter that runs Nuitka do all the hard work. "
"This lives in ``CompileTimeConstantExpressionBase`` and is the base for "
"all kinds of constant values, or even built-in references like the name "
"``len`` itself and would be used in case of doing ``len(len)`` which "
"obviously gives an exception."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1628
msgid ""
"Other overloads do not currently exist in Nuitka, but through the "
"iteration length, most cases could be addressed, e.g. ``list`` nodes "
"typical know their element counts."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1633
msgid "The C side"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1635
msgid ""
"When a slot is not optimized away at compile time however, we need to "
"generate actual code for it. We figure out what this could be by looking "
"at the original CPython implementation."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1650
msgid ""
"We find a pointer to ``PyObject_Size`` which is a generic Python C/API "
"function used in the ``builtin_len`` implementation:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1670
msgid ""
"On the C level, every Python object (the ``PyObject *``) as a type named "
"``ob_type`` and most of its elements are slots. Sometimes they form a "
"group, here ``tp_as_sequence`` and then it may or may not contain a "
"function. This one is tried in preference. Then, if that fails, next up "
"the mapping size is tried."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1694
msgid ""
"This is the same principle, except with ``tp_as_mapping`` and "
"``mp_length`` used."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1697
msgid ""
"So from this, we can tell how ``len`` gets at what could be a Python "
"class ``__len__`` or other built-in types."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1700
msgid ""
"In principle, every slot needs to be dealt with in Nuitka, and it is "
"assumed that currently all slots are supported on at least a very "
"defensive level, to avoid unnoticed escapes of control flow."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1705
msgid "Built-in call optimization"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1707
msgid ""
"For calls to built-in names, there is typically a function in Python that"
" delegates to the type constructor (e.g. when we talk about ``int`` that "
"just creates an object passing the arguments of the call) or its own "
"special implementation as we saw with the ``len``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1712
msgid ""
"For each built-in called, we have a specialized node, that presents to "
"optimization the actions of the built-in. What are the impact, what are "
"the results. We have seen the resulting example for ``len`` above, but "
"how do we get there."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1717
msgid ""
"In Python, built-in names are used only if there is no module level "
"variable of the name, and of course no local variable of that name."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1720
msgid ""
"Therefore, optimization of a built-in name is only done if it turns out "
"the actually assigned in other code, and then when the call comes, "
"arguments are checked and a relatively static node is created."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1725
msgid "Code Generation towards C"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1727
msgid ""
"Currently, Nuitka uses Pure C and no C++ patterns at all. The use of C11 "
"requires on some platforms to compile the C11 using a C++ compiler, which"
" works relatively well, but also limits the amount of C11 that can be "
"used."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1733
msgid "Exceptions"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1735
msgid ""
"To handle and work with exceptions, every construct that can raise has "
"either a ``bool`` or ``int`` return code or ``PyObject *`` with ``NULL`` "
"return value. This is very much in line with that the Python C-API does."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1739
msgid ""
"Every helper function that contains code that might raise needs these "
"variables. After a failed call, our variant of ``PyErr_Fetch`` called "
"``FETCH_ERROR_OCCURRED`` must be used to catch the defined error, unless "
"some quick exception cases apply. The quick exception means, ``NULL`` "
"return from C-API without a set exception means e.g. ``StopIteration``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1745
msgid ""
"As an optimization, functions that raise exceptions, but are known not to"
" do so, for whatever reason, could only be asserted to not do so."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1749
msgid "Statement Temporary Variables"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1751
msgid ""
"For statements and larger constructs the context object track temporary "
"values, that represent references. For some, these should be released at "
"the end of the statement, or they represent a leak."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1755
msgid ""
"The larger scope temporary variables, are tracked in the function or "
"module context, where they are supposed to have explicit ``del`` to "
"release their references."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1760
msgid "Local Variables Storage"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1762
msgid ""
"Closure variables taken are to be released when the function object is "
"later destroyed. For in-lined calls, variables are just passed, and it "
"does not become an issue to release anything."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1766
msgid ""
"For function exit, owned variables, local or shared to other functions, "
"must be released. This cannot be a ``del`` operation, as it also involves"
" setting a value, which would be wrong for shared variables (and wasteful"
" to local variables, as that would be its last usage). Therefore we need "
"a special operation that simply releases the reference to the cell or "
"object variable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1774
msgid "Exit Targets"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1776
msgid ""
"Each error or other exit releases statement temporary values and then "
"executes a ``goto`` to the exit target. These targets need to be setup. "
"The ``try``/``except`` will e.g. catch error exits."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1780
msgid ""
"Other exits are ``continue``, ``break``, and ``return`` exits. They all "
"work alike."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1783
msgid ""
"Generally, the exits stack of with constructs that need to register "
"themselves for some exit types. A loop e.g. registers the ``continue`` "
"exit, and a contained ``try``/``finally`` too, so it can execute the "
"final code should it be needed."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1789
msgid "Frames"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1791
msgid ""
"Frames are containers for variable declarations and cleanups. As such, "
"frames provide error exits and success exits, which remove the frame from"
" the frame stack, and then proceed to the parent exit."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1795
msgid ""
"With the use of non ``PyObject **`` C types, but frame exception exits, "
"the need to convert those types becomes apparent. Exceptions should still"
" resolve the C version. When using different C types at frame exception "
"exits, there is a need to trace the active type, so it can be used in the"
" correct form."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1802
msgid "Abortive Statements"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1804
msgid ""
"The way ``try``/``finally`` is handled, copies of the ``finally`` block "
"are made, and optimized independently for each abort method. The ones "
"there are of course, ``return``, ``continue``, and ``break``, but also "
"implicit and explicit ``raise`` of an exception."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1809
msgid ""
"Code trailing an abortive statement can be discarded, and the control "
"flow will follow these \"exits\"."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1813
msgid "Constant Preparation"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1815
msgid ""
"Early versions of Nuitka, created all constants for the whole program for"
" ready access to generated code, before the program launches. It did so "
"in a single file, but that approach didn't scale well."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1819
msgid "Problems were"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1821
msgid ""
"Even unused code contributed to start-up time, this can become a lot for "
"large programs, especially in standalone mode."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1824
msgid ""
"The massive amount of constant creation codes gave backend C compilers a "
"much harder time than necessary to analyse it all at once."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1828
msgid ""
"The current approach is as follows. Code generation detects constants "
"used in only one module, and declared ``static`` there, if the module is "
"the only user, or ``extern`` if it is not. Some values are forced to be "
"global, as they are used pre-main or in helpers."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1833
msgid ""
"These ``extern`` values are globally created before anything is used. The"
" ``static`` values are created when the module is loaded, i.e. something "
"did import it."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1837
msgid ""
"We trace used constants per module, and for nested ones, we also "
"associate them. The global constants code is special in that it can only "
"use ``static`` for nested values it exclusively uses, and has to export "
"values that others use."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1843
msgid "Language Conversions to make things simpler"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1845
msgid ""
"There are some cases, where the Python language has things that can in "
"fact be expressed in a simpler or more general way, and where we choose "
"to do that at either tree building or optimization time."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1850
msgid "The ``assert`` statement"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1852
msgid ""
"The ``assert`` statement is a special statement in Python, allowed by the"
" syntax. It has two forms, with and without a second argument. The later "
"is probably less known, as is the fact that raise statements can have "
"multiple arguments too."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1857
msgid "The handling in Nuitka is:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1873
msgid ""
"This makes assertions absolutely the same as a raise exception in a "
"conditional statement."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1876
msgid ""
"This transformation is performed at tree building already, so Nuitka "
"never knows about ``assert`` as an element and standard optimizations "
"apply. If e.g. the truth value of the assertion can be predicted, the "
"conditional statement will have the branch statically executed or "
"removed."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1883
msgid "The \"comparison chain\" expressions"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1885
msgid ""
"In Nuitka we have the concept of an outline, and therefore we can make "
"the following re-formulation instead:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1917
msgid ""
"This transformation is performed at tree building already. The temporary "
"variables keep the value for the use of the same expression. Only the "
"last expression needs no temporary variable to keep it."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1921
msgid ""
"What we got from this, is making the checks of the comparison chain "
"explicit and comparisons in Nuitka to be internally always about two "
"operands only."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1926
msgid "The ``execfile`` built-in"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1928
msgid "Handling is:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1938
msgid ""
"This allows optimizations to discover the file opening nature easily and "
"apply file embedding or whatever we will have there one day."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1941
msgid ""
"This transformation is performed when the ``execfile`` built-in is "
"detected as such during optimization."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1945
msgid "Generator expressions with ``yield``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1947
msgid ""
"These are converted at tree building time into a generator function body "
"that yields from the iterator given, which is the put into a for loop to "
"iterate, created a lambda function of and then called with the first "
"iterator."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1952
msgid ""
"That eliminates the generator expression for this case. It's a bizarre "
"construct and with this trick needs no special code generation."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1955
msgid ""
"This is a complex example, demonstrating multiple cases of yield in "
"unexpected cases:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1968
msgid "Function Decorators"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1970
msgid "When one learns about decorators, you see that:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1986
msgid ""
"The only difference is the assignment to function. In the ``@decorator`` "
"case, if the decorator fails with an exception, the name ``function`` is "
"not assigned yet, but kept in a temporary variable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1990
msgid ""
"Therefore in Nuitka this assignment is more similar to that of a lambda "
"expression, where the assignment to the name is only at the end, which "
"also has the extra benefit of not treating real function and lambda "
"functions any different."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:1995
msgid ""
"This removes the need for optimization and code generation to support "
"decorators at all. And it should make the two variants optimize equally "
"well."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2000
msgid "Functions nested arguments"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2002
msgid ""
"Nested arguments are a Python2 only feature supported by Nuitka. Consider"
" this example:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2010
msgid ""
"We solve this, by kind of wrapping the function with another function "
"that does the unpacking and gives the errors that come from this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2022
msgid ""
"The ``.1`` is the variable name used by CPython internally, and actually "
"works if you use keyword arguments via star dictionary. So this is very "
"compatible and actually the right kind of re-formulation, but it removes "
"the need from the code that does parameter parsing to deal with these."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2027
msgid ""
"Obviously, there is no frame for ``_tmp``, just one for ``function`` and "
"we do not use local variables, but temporary functions."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2031
msgid "In-place Assignments"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2033
msgid ""
"In-place assignments are re-formulated to an expression using temporary "
"variables."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2036
msgid ""
"These are not as much a reformulation of ``+=`` to ``+``, but instead one"
" which makes it explicit that the assign target may change its value."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2050
msgid ""
"Using ``__iadd__`` here to express that for the ``+``, the in-place "
"variant ``iadd`` is used instead. The ``is`` check may be optimized away "
"depending on type and value knowledge later on."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2055
msgid "Complex Assignments"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2057
msgid ""
"Complex assignments are defined as those with multiple targets to assign "
"from a single source and are re-formulated to such using a temporary "
"variable and multiple simple assignments instead."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2072
msgid ""
"This is possible, because in Python, if one assignment fails, it can just"
" be interrupted, so in fact, they are sequential, and all that is "
"required is to not calculate ``c`` twice, which the temporary variable "
"takes care of. Were ``b`` a more complex expression, e.g. "
"``b.some_attribute`` that might raise an exception, ``a`` would still be "
"assigned."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2080
msgid "Unpacking Assignments"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2082
msgid ""
"Unpacking assignments are re-formulated to use temporary variables as "
"well."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2089
msgid "Becomes this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2113
msgid ""
"That way, the unpacking is decomposed into multiple simple statements. It"
" will be the job of optimizations to try and remove unnecessary "
"unpacking, in case e.g. the source is a known tuple or list creation."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2119
msgid ""
"The ``unpack`` is a special node which is a form of ``next`` that will "
"raise a ``ValueError`` when it cannot get the next value, rather than a "
"``StopIteration``. The message text contains the number of values to "
"unpack, therefore the integer argument."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2126
msgid ""
"The ``unpack_check`` is a special node that raises a ``ValueError`` "
"exception if the iterator is not finished, i.e. there are more values to "
"unpack. Again the number of values to unpack is provided to construct the"
" error message."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2132
msgid "With Statements"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2134
msgid ""
"The ``with`` statements are re-formulated to use temporary variables as "
"well. The taking and calling of ``__enter__`` and ``__exit__`` with "
"arguments, is presented with standard operations instead. The promise to "
"call ``__exit__`` is fulfilled by ``try``/``except`` clause instead."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2185
msgid ""
"We don't refer really to ``sys.exc_info()`` at all, instead, we have fast"
" references to the current exception type, value and trace, taken "
"directly from the caught exception object on the C level."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2189
msgid ""
"If we had the ability to optimize ``sys.exc_info()`` to do that, we could"
" use the same transformation, but right now we don't have it."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2193
msgid "For Loops"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2195
msgid ""
"The ``for`` loops use normal assignments and handle the iterator that is "
"implicit in the code explicitly."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2206
msgid "This is roughly equivalent to the following code:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2236
msgid ""
"The ``_iter`` temporary variable is of course also in a ``try/finally`` "
"construct, to make sure it releases after its used. The ``x, y`` "
"assignment is of course subject to unpacking re-formulation."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2241
msgid ""
"The ``try``/``except`` is detected to allow to use a variant of ``next`` "
"that does not raise an exception, but to be fast check about the ``NULL``"
" return from ``next`` built-in. So no actual exception handling is "
"happening in this case."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2247
msgid "While Loops"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2249
msgid ""
"Quoting the ``nuitka.tree.ReformulationWhileLoopStatements`` "
"documentation:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2252
msgid "Reformulation of while loop statements."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2254
msgid ""
"Loops in Nuitka have no condition attached anymore, so while loops are "
"re-formulated like this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2270
msgid ""
"This is to totally remove the specialization of loops, with the condition"
" moved to the loop body in an initial conditional statement, which "
"contains a ``break`` statement."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2274
msgid ""
"That achieves, that only ``break`` statements exit the loop, and allow "
"for optimization to remove always true loop conditions, without "
"concerning code generation about it, and to detect such a situation, "
"consider e.g. endless loops."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2281
msgid ""
"Loop analysis (not yet done) can then work on a reduced problem (which "
"``break`` statements are executed under what conditions) and is then "
"automatically very general."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2285
msgid ""
"The fact that the loop body may not be entered at all, is still "
"optimized, but also in the general sense. Explicit breaks at the loop "
"start and loop conditions are the same."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2289
msgid ""
"End quoting the ``nuitka.tree.ReformulationWhileLoopStatements`` "
"documentation:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2293
msgid "Exception Handlers"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2295
msgid ""
"Exception handlers in Python may assign the caught exception value to a "
"variable in the handler definition. And the different handlers are "
"represented as conditional checks on the result of comparison operations."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2331
msgid ""
"For Python3, the assigned ``e`` variables get deleted at the end of the "
"handler block. Should that value be already deleted, that ``del`` does "
"not raise, therefore it's tolerant. This has to be done in any case, so "
"for Python3 it is even more complex."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2362
msgid ""
"Should there be no ``else:`` branch, a default re-raise statement is used"
" instead."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2365
msgid ""
"And of course, the values of the current exception type and value, both "
"use special references, that access the C++ and don't go via "
"``sys.exc_info`` at all, nodes called ``CaughtExceptionTypeRef`` and "
"``CaughtExceptionValueRef``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2370
msgid ""
"This means, that the different handlers and their catching run time "
"behavior are all explicit and reduced the branches."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2374
msgid "Statement ``try``/``except`` with ``else``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2376
msgid ""
"Much like ``else`` branches of loops, an indicator variable is used to "
"indicate the entry into any of the exception handlers."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2379
msgid ""
"Therefore, the ``else`` becomes a real conditional statement in the node "
"tree, checking the indicator variable and guarding the execution of the "
"``else`` branch."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2384
msgid "Class Creation (Python2)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2386
msgid ""
"Classes in Python2 have a body that only serves to build the class "
"dictionary and is a normal function otherwise. This is expressed with the"
" following re-formulation:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2422
msgid ""
"That is roughly the same, except that ``_makeSomeClass`` is *not* visible"
" to its child functions when it comes to closure taking, which we cannot "
"express in Python language at all."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2426
msgid ""
"Therefore, class bodies are just special function bodies that create a "
"dictionary for use in class creation. They don't really appear after the "
"tree building stage anymore. The type inference will of course have to "
"become able to understand ``make_class`` quite well, so it can recognize "
"the created class again."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2433
msgid "Class Creation (Python3)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2435
msgid ""
"In Python3, classes are a complicated way to write a function call, that "
"can interact with its body. The body starts with a dictionary provided by"
" the metaclass, so that is different, because it can ``__prepare__`` a "
"non-empty locals for it, which is hidden away in \"prepare_class_dict\" "
"below."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2441
msgid ""
"What's noteworthy, is that this dictionary, could e.g. be an "
"``OrderDict``. I am not sure, what ``__prepare__`` is allowed to return."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2492
msgid "Generator Expressions"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2494
msgid "There are re-formulated as functions."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2496
msgid ""
"Generally they are turned into calls of function bodies with (potentially"
" nested) for loops:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2514
msgid "List Contractions"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2516
msgid ""
"The list contractions of Python2 are different from those of Python3, in "
"that they don't actually do any closure variable taking, and that no "
"function object ever exists."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2538
msgid ""
"The difference is that with Python3, the function \"_listcontr_helper\" "
"is really there and named ``<listcontraction>`` (or ``<listcomp>`` as of "
"Python3.7 or higher), whereas with Python2 the function is only an "
"outline, so it can readily access the containing name space."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2544
msgid "Set Contractions"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2546
msgid ""
"The set contractions of Python2.7 are like list contractions in Python3, "
"in that they produce an actual helper function:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2568
msgid "Dictionary Contractions"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2570
msgid ""
"The dictionary contractions of are like list contractions in Python3, in "
"that they produce an actual helper function:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2592
msgid "Boolean expressions ``and`` and ``or``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2594
msgid ""
"The short circuit operators ``or`` and ``and`` tend to be only less "
"general that the ``if``/``else`` expressions, but have dedicated nodes. "
"We used to have a re-formulation towards those, but we now do these via "
"dedicated nodes too."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2599
msgid ""
"These new nodes, present the evaluation of the left value, checking for "
"its truth value, and depending on it, to pick it, or use the right value."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2604
msgid "Simple Calls"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2606
msgid ""
"As seen below, even complex calls are simple calls. In simple calls of "
"Python there is still some hidden semantic going on, that we expose."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2613
msgid ""
"On the C-API level there is a tuple and dictionary built. This one is "
"exposed:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2620
msgid ""
"A called function will access this tuple and the dictionary to parse the "
"arguments, once that is also re-formulated (argument parsing), it can "
"then lead to simple in-lining. This way calls only have 2 arguments with "
"constant semantics, that fits perfectly with the C-API where it is the "
"same, so it is actually easier for code generation."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2626
msgid ""
"Although the above looks like a complex call, it actually is not. No "
"checks are needed for the types of the star arguments and it's directly "
"translated to ``PyObject_Call``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2631
msgid "Complex Calls"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2633
msgid "The call operator in Python allows to provide arguments in 4 forms."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2635
msgid "Positional (or normal) arguments"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2637
msgid "Named (or keyword) arguments"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2639
msgid "Star list arguments"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2641
msgid "Star dictionary arguments"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2643
msgid "The evaluation order is precisely that. An example would be:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2649
msgid ""
"The task here is that first all the arguments are evaluated, left to "
"right, and then they are merged into only two, that is positional and "
"named arguments only. for this, the star list argument and the star "
"dictionary arguments, are merged with the positional and named arguments."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2655
msgid ""
"What's peculiar, is that if both the star list and dictionary arguments "
"are present, the merging is first done for star dictionary, and only "
"after that for the star list argument. This makes a difference, because "
"in case of an error, the star argument raises first."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2664
msgid ""
"This raises \"TypeError: something() argument after ** must be a mapping,"
" not int\" as opposed to a possibly more expected \"TypeError: "
"something() argument after * must be a sequence, not int.\""
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2668
msgid ""
"That doesn't matter much though, because the value is to be evaluated "
"first anyway, and the check is only performed afterwards. If the star "
"list argument calculation gives an error, this one is raised before "
"checking the star dictionary argument."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2673
msgid ""
"So, what we do, is we convert complex calls by the way of special "
"functions, which handle the dirty work for us. The optimization is then "
"tasked to do the difficult stuff. Our example becomes this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2701
msgid ""
"The call to ``_complex_call`` is be a direct function call with no "
"parameter parsing overhead. And the call in its end, is a special call "
"operation, which relates to the ``PyObject_Call`` C-API."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2706
msgid "Match Statements"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2718
msgid "This is the same as"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2746
msgid "Print Statements"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2748
msgid ""
"The ``print`` statement exists only in Python2. It implicitly converts "
"its arguments to strings before printing them. In order to make this "
"accessible and compile time optimized, this is made visible in the node "
"tree."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2757
msgid ""
"This is in Nuitka converted so that the code generation for ``print`` "
"doesn't do any conversions itself anymore and relies on the string nature"
" of its input."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2765
msgid ""
"Only string objects are spared from the ``str`` built-in wrapper, because"
" that would only cause noise in optimization stage. Later optization can "
"then find it unnecessary for certain arguments."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2769
msgid ""
"Additionally, each ``print`` may have a target, and multiple arguments, "
"which we break down as well for dumber code generation. The target is "
"evaluated first and should be a file, kept referenced throughout the "
"whole print statement."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2778
msgid "This is being reformulated to:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2791
msgid ""
"This allows code generation to not deal with arbitrary amount of "
"arguments to ``print``. It also separates the newline indicator from the "
"rest of things, which makes sense too, having it as a special node, as "
"it's behavior with regards to soft-space is different of course."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2796
msgid ""
"And finally, for ``print`` without a target, we still assume that a "
"target was given, which would be ``sys.stdout`` in a rather hard-coded "
"way (no variable look-ups involved)."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2801
msgid "Reformulations during Optimization"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2804
msgid "Builtin ``zip`` for Python2"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2851
msgid "Builtin ``zip`` for Python3"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2881
msgid "Builtin ``map`` for Python2"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2890
msgid "Builtin ``min``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2923
msgid "Builtin ``max``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2925
msgid "See ``min`` just with ``>`` instead of ``<``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2928
msgid "Call to ``dir`` without arguments"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2930
msgid ""
"This expression is reformulated to ``locals().keys()`` for Python2, and "
"``list(locals.keys())`` for Python3."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2934
msgid "Calls to functions with known signatures"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2936
msgid ""
"As a necessary step for inlining function calls, we need to change calls "
"to variable references to function references."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2949
msgid "In the optimization it is turned into"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2959
msgid ""
"The ``lambda`` stands here for a reference to the function, rather than a"
" variable reference, this is the normal forward propagation of values, "
"and does not imply duplicating or moving any code at all."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2963
msgid ""
"At this point, we still have not resolved the actual call arguments to "
"the variable names, still a Python level function is created, and called,"
" and arguments are parsed to a tuple, and from a tuple. For simplicity "
"sake, we have left out keyword arguments out of the equation for now, but"
" they are even more costly."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2969
msgid ""
"So now, what we want to do, is to re-formulate the call into what we call"
" an outline body, which is a inline function, and that does the parameter"
" parsing already and contains the function code too. In this inlining, "
"there still is a function, but it's technically not a Python function "
"anymore, just something that is an expression whose value is determined "
"by control flow and the function call."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2989
msgid ""
"With this, a function is considered inlined, because it becomes part of "
"the abstract execution, and the actual code is duplicated."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2992
msgid ""
"The point is, that matching the signature of the function to the actual "
"arguments given, is pretty straight forward in many cases, but there are "
"two forms of complications that can happen. One is default values, "
"because they need to assigned or not, and the other is keyword arguments,"
" because they allow to reorder arguments."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:2998
msgid "Lets consider an example with default values first."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3010
msgid ""
"Since the point, at which defaults are taken, we must execute them at "
"that point and make them available."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3028
msgid "Now, one where keyword arguments are ordered the other way."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3040
msgid ""
"The solution is an extra level of temporary variables. We remember the "
"argument order by names and then assign parameters from it:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3058
msgid ""
"Obviously, optimization of Nuitka can decide, that e.g. should ``a`` or "
"``b+c`` not have side effects, to optimize these with standard variable "
"tracing away."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3063
msgid "Nodes that serve special purposes"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3066
msgid "Try statements"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3068
msgid ""
"In Python, there is ``try``/``except`` and ``try``/``finally``. In Nuitka"
" there is only a ``try``, which then has blocks to handle exceptions, "
"``continue``, or ``break``, or ``return``. There is no ``else`` to this "
"node type."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3073
msgid ""
"This is more low level and universal. Code for the different handlers can"
" be different. User provided ``finally`` blocks become copied into the "
"different handlers."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3078
msgid "Releases"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3080
msgid ""
"When a function exits, the local variables are to be released. The same "
"applies to temporary variables used in re-formulations. These releases "
"cause a reference to the object to the released, but no value change. "
"They are typically the last use of the object in the function."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3085
msgid ""
"The are similar to ``del``, but make no value change. For shared "
"variables this effect is most visible."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3089
msgid "Side Effects"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3091
msgid ""
"When an exception is bound to occur, and this can be determined at "
"compile time, Nuitka will not generate the code the leads to the "
"exception, but directly just raise it. But not in all cases, this is the "
"full thing."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3096
msgid "Consider this code:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3102
msgid ""
"The second argument will create a ``ZeroDivisionError`` exception, but "
"before that ``a()`` must be executed, but the call to ``f`` will never "
"happen and no code is needed for that, but the name look-up must still "
"succeed. This then leads to code that is internally like this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3111
msgid "which is then modeled as:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3117
msgid ""
"where we can consider ``side_effect`` to be a function that returns the "
"last expression. Of course, if this is not part of another expression, "
"but close to statement level, side effects, can be converted to multiple "
"statements simply."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3122
msgid ""
"Another use case, is that the value of an expression can be predicted, "
"but that the language still requires things to happen, consider this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3129
msgid ""
"We can tell that ``a`` will be 2, but the call to ``f`` and ``g`` must "
"still be performed, so it becomes:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3136
msgid ""
"Modelling side effects explicitly has the advantage of recognizing them "
"easily and allowing to drop the call to the tuple building and checking "
"its length, only to release it."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3141
msgid "Caught Exception Type/Value References"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3143
msgid ""
"When catching an exception, these are not directly put to "
"``sys.exc_info()``, but remain as mere C variables. From there, they can "
"be accessed with these nodes, or if published then from the thread state."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3149
msgid "Hard Module Imports"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3151
msgid ""
"These are module look-ups that don't depend on any local variable for the"
" module to be looked up, but with hard-coded names. These may be the "
"result of optimization gaining such level of certainty."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3155
msgid ""
"Currently they are used to represent ``sys.stdout`` usage for ``print`` "
"statements, but other usages will follow."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3159
msgid "Locals Dict Update Statement"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3161
msgid ""
"For the ``exec`` re-formulation, we apply an explicit sync back to locals"
" as an explicit node. It helps us to tell the affected local variable "
"traces that they might be affected. It represents the bit of ``exec`` in "
"Python2, that treats ``None`` as the locals argument as an indication to "
"copy back."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3168
msgid "Optimizing Attribute Lookups into Method Calls for Built-ins types"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3170
msgid ""
"The attribute lookup node ``ExpressionAttributeLookup`` represents "
"looking up an attribute name, that is known to be a string. That's "
"already a bit more special, than say what ``ExpressionBuiltinGetattr`` "
"does for ``getattr``, where it could be any object being looked up. From "
"the Python syntax however, these are what gets created, as it's not "
"allowed in any other way. So, this is where this starts."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3177
msgid ""
"Then, when we are creating an attribute node with a *fixed* name, we "
"dispatch it to generated node classes, e.g. "
"``ExpressionAttributeLookupFixedAppend``. This will be the same, except "
"that the attribute name is hardcoded."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3182
msgid ""
"There are generated, such that they can have code that is special for "
"``.append`` lookups. In their case, it makes sense to ask the source, if "
"they are a ``list`` object exactly. It doesn't make sense to do this "
"check for names that the ``list`` does not contain. So at that stage, we "
"are saving both a bit of memory and time."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3188
msgid ""
"Should this question succeed, i.e. the expression the attribute values is"
" looked up upon, is known to be a ``list`` exactly, we persist this "
"knowledge in the also generated nodes that represent ``list.append`` and "
"just that. It is called ``ExpressionAttributeLookupListAppend`` and only "
"represents the knowledge gained so far."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3194
msgid ""
"We do not consider if ``ExpressionAttributeLookupFixedAppend`` is called,"
" or not, passed as an argument, assigned somewhere, it doesn't matter "
"yet, but for ``ExpressionAttributeLookupListAppend`` we know a hell of a "
"lot more. We know its type, we know attributes for it, say ``__name__``, "
"as it is a compile time constant, therefore much optimization can follow "
"for them, and code generation can specialize them too (not yet done)."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3202
msgid ""
"Should these nodes then, and say this happens later after some inlining "
"happens be seen as called, we can then turn them into method call nodes, "
"checking the arguments and such, this is then "
"``ExpressionListOperationAppend`` and at this point, will raising errors "
"with wrong argument counts."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3208
msgid ""
"And then we have this ``ExpressionListOperationAppend`` which will "
"influence the tracing of ``list`` contents, i.e. it will be able to tell "
"the ``list`` in question is no more empty after this ``append``, and it "
"will be able to at least predict the last element value, truth value of "
"the list, etc."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3216
msgid "Plan to add \"ctypes\" support"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3218
msgid ""
"Add interfacing to C code, so Nuitka can turn a ``ctypes`` binding into "
"an efficient binding as if it were written manually with Python C-API or "
"better."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3223
msgid "Goals/Allowances to the task"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3225
msgid ""
"Goal: Must not directly use any pre-existing C/C++ language file headers,"
" only generate declarations in generated C code ourselves. We would "
"rather write or use tools that turn an existing a C header to some "
"``ctypes`` declarations if it needs to be, but not mix and use "
"declarations from existing header code."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3233
msgid ""
"The \"cffi\" interface maybe won't have the issue, but it's not something"
" we need to write or test the code for."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3236
msgid ""
"Allowance: May use ``ctypes`` module at compile time to ask things about "
"``ctypes`` and its types."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3239
msgid ""
"Goal: Should make use of ``ctypes``, to e.g. not hard code in Nuitka what"
" ``ctypes.c_int()`` gives on the current platform, unless there is a "
"specific benefit."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3243
msgid "Allowance: Not all ``ctypes`` usages must be supported immediately."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3245
msgid "Goal: Try and be as general as possible."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3247
msgid ""
"For the compiler, ``ctypes`` support should be hidden behind a generic "
"interface of some sort. Supporting ``math`` module should be the same "
"thing."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3252
msgid "Type Inference - The Discussion"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3254
msgid ""
"Main initial goal is to forward value knowledge. When you have ``a = b``,"
" that means that a and b now \"alias\". And if you know the value of "
"``b`` you can assume to know the value of ``a``. This is called "
"\"aliasing\"."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3259
msgid ""
"When assigning ``a`` to something new, that won't change ``b`` at all. "
"But when an attribute is set, a method called of it, that might impact "
"the actual value, referenced by both. We need to understand mutable vs. "
"immutable though, as some things are not affectable by aliasing in any "
"way."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3277
msgid ""
"If we cannot tell, we must assume that ``a`` might be changed. It's "
"either ``b`` or what ``a`` was before. If the type is not mutable, we can"
" assume the aliasing to be broken up, and if it is, we can assume both to"
" be the same value still."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3282
msgid ""
"When that value is a compile time constant, we will want to push it "
"forward, and we do that with \"(Constant) Value Propagation\", which is "
"implemented already. We avoid too large constants, and we properly trace "
"value assignments, but not yet aliases."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3287
msgid ""
"In order to fully benefit from type knowledge, the new type system must "
"be able to be fully friends with existing built-in types, but for classes"
" to also work with it, it should not be tied to them. The behavior of a "
"type ``long``, ``str``, etc. ought to be implemented as far as possible "
"with the built-in ``long``, ``str`` at compiled time as well."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3296
msgid ""
"This \"use the real thing\" concept extends beyond builtin types, e.g. "
"``ctypes.c_int()`` should also be used, but we must be aware of platform "
"dependencies. The maximum size of ``ctypes.c_int`` values would be an "
"example of that. Of course that may not be possible for everything."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3302
msgid ""
"This approach has well proven itself with built-in functions already, "
"where we use real built-ins where possible to make computations. We have "
"the problem though that built-ins may have problems to execute everything"
" with reasonable compile time cost."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3307
msgid "Another example, consider the following code:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3313
msgid ""
"To predict this code, calculating it at compile time using constant "
"operations, while feasible, puts an unacceptable burden on the "
"compilation."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3317
msgid ""
"Esp. we wouldn't want to produce such a huge constant and stream it, the "
"C++ code would become too huge. So, we need to stop the ``*`` operator "
"from being used at compile time and cope with reduced knowledge, already "
"here:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3326
msgid "Instead, we would probably say that for this expression:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3328
msgid "The result is a ``str`` or a C level ``PyStringObject *``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3330
msgid "We know its length exactly, it's ``10000000000000``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3332
msgid ""
"Can predict every of its elements when sub-scripted, sliced, etc., if "
"need be, with a function we may create."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3335
msgid "Similar is true for this horrible (in Python2) thing:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3341
msgid "So it's a rather general problem, this time we know:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3343
msgid "The result is a ``list`` or C level ``PyListObject *``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3345
msgid "We know its length exactly, ``10000000000000``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3347
msgid ""
"Can predict every of its elements when index, sliced, etc., if need be, "
"with a function."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3350
msgid ""
"Again, we wouldn't want to create the list. Therefore Nuitka avoids "
"executing these calculation, when they result in constants larger than a "
"threshold of e.g. 256 elements. This concept has to be also applied to "
"large integers and more CPU and memory traps."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3355
msgid "Now lets look at a more complete use case:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3362
msgid ""
"Looking at this example, one traditional way to look at it, would be to "
"turn ``range`` into ``xrange``, and to note that ``x`` is unused. That "
"would already perform better. But really better is to notice that "
"``range()`` generated values are not used at all, but only the length of "
"the expression matters."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3368
msgid ""
"And even if ``x`` were used, only the ability to predict the value from a"
" function would be interesting, so we would use that computation function"
" instead of having an iteration source. Being able to predict from a "
"function could mean to have Python code to do it, as well as C code to do"
" it. Then code for the loop can be generated without any CPython library "
"usage at all."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3377
msgid ""
"Of course, it would only make sense where such calculations are \"O(1)\" "
"complexity, i.e. do not require recursion like \"n!\" does."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3380
msgid ""
"The other thing is that CPython appears to at - run time - take length "
"hints from objects for some operations, and there it would help too, to "
"track length of objects, and provide it, to outside code."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3384
msgid "Back to the original example:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3390
msgid ""
"The theme here, is that when we can't compute all intermediate "
"expressions, and we sure can't do it in the general case. But we can "
"still, predict some of properties of an expression result, more or less."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3394
msgid ""
"Here we have ``len`` to look at an argument that we know the size of. "
"Great. We need to ask if there are any side effects, and if there are, we"
" need to maintain them of course. This is already done by existing "
"optimization if an operation generates an exception."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3401
msgid ""
"The optimization of ``len`` has been implemented and works for all kinds "
"of container creation and ranges."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3405
msgid "Applying this to \"ctypes\""
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3407
msgid ""
"The *not so specific* problem to be solved to understand ``ctypes`` "
"declarations is maybe as follows:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3414
msgid ""
"This leads to Nuitka in its tree to have an assignment from a "
"``__import__`` expression to the variable ``ctypes``. It can be predicted"
" by default to be a module object, and even better, it can be known as "
"``ctypes`` from standard library with more or less certainty. See the "
"section about \"Importing\"."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3420
msgid ""
"So that part is \"easy\", and it's what will happen. During optimization,"
" when the module ``__import__`` expression is examined, it should say:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3423
msgid "``ctypes`` is a module"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3425
msgid "``ctypes`` is from standard library (if it is, might not be true)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3427
msgid ""
"``ctypes`` then has code behind it, called ``ModuleFriend`` that knows "
"things about it attributes, that should be asked."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3430
msgid ""
"The later is the generic interface, and the optimization should connect "
"the two, of course via package and module full names. It will need a "
"``ModuleFriendRegistry``, from which it can be pulled. It would be nice "
"if we can avoid ``ctypes`` to be loaded into Nuitka unless necessary, so "
"these need to be more like a plug-in, loaded only if necessary, i.e. the "
"user code actually uses ``ctypes``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3437
msgid ""
"Coming back to the original expression, it also contains an assignment "
"expression, because it re-formulated to be more like this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3444
msgid ""
"The assigned to object, simply gets the type inferred propagated as part "
"of an SSA form. Ideally, we could be sure that nothing in the program "
"changes the variable, and therefore have only one version of that "
"variable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3449
msgid ""
"For module variables, when the execution leaves the module to unknown "
"code, or unclear code, it might change the variable. Therefore, likely we"
" will often only assume that it could still be ``ctypes``, but also "
"something else."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3454
msgid ""
"Depending on how well we control module variable assignment, we can "
"decide this more of less quickly. With \"compiled modules\" types, the "
"expectation is that it's merely a quick C ``==`` comparison check. The "
"module friend should offer code to allow a check if it applies, for "
"uncertain cases."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3460
msgid "Then when we come to uses of it:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3466
msgid ""
"At this point, using SSA, we are more of less sure, that ``ctypes`` is at"
" that point the module, and that we know what it's ``c_int`` attribute "
"is, at compile time, and what it's call result is. We will use the module"
" friend to help with that. It will attach knowledge about the result of "
"that expression during the SSA collection process."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3472
msgid ""
"This is more like a value forward propagation than anything else. In "
"fact, constant propagation should only be the special case of it, and one"
" design goal of Nuitka was always to cover these two cases with the same "
"code."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3478
msgid "Excursion to Functions"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3480
msgid ""
"In order to decide what this means to functions and their call "
"boundaries, if we propagate forward, how to handle this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3490
msgid ""
"We annotate that ``a`` is first a \"unknown but defined parameter "
"object\", then later on something that definitely has an ``append`` "
"attribute, when returned, as otherwise an exception occurs."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3494
msgid ""
"The type of ``a`` changes to that after ``a.append`` look-up succeeds. It"
" might be many kinds of an object, but e.g. it could have a higher "
"probability of being a ``PyListObject``. And we would know it cannot be a"
" ``PyStringObject``, as that one has no ``append`` method, and would have"
" raised an exception therefore."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3502
msgid ""
"If classes, i.e. other types in the program, have an ``append`` "
"attribute, it should play a role too, there needs to be a way to plug-in "
"to this decisions."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3508
msgid "On the other hand, types without ``append`` attribute can be eliminated."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3511
msgid ""
"Therefore, functions through SSA provide an automatic analysis on their "
"return state, or return value types, or a quick way to predict return "
"value properties, based on input value knowledge."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3515
msgid "So this could work:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3523
msgid ""
"Goal: The structure we use makes it easy to tell what ``my_append`` may "
"be. So, there should be a means to ask it about call results with given "
"type/value information. We need to be able to tell, if evaluating "
"``my_append`` makes sense with given parameters or not, if it does impact"
" the return value."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3529
msgid "We should e.g. be able to make ``my_append`` tell, one or more of these:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3531
msgid ""
"Returns the first parameter value as return value (unless it raises an "
"exception)."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3534
msgid ""
"The return value has the same type as ``a`` (unless it raises an "
"exception)."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3537
msgid "The return value has an ``append`` attribute."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3539
msgid "The return value might be a ``list`` object."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3541
msgid "The return value may not be a ``str`` object."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3543
msgid "The function will raise if first argument has no ``append`` attribute."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3546
msgid ""
"The exactness of statements may vary. But some things may be more "
"interesting. If e.g. the aliasing of a parameter value to the return "
"value is known exactly, then information about it need to all be given "
"up, but some can survive."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3551
msgid ""
"It would be nice, if ``my_append`` had sufficient information, so we "
"could specialize with ``list`` and ``int`` from the parameters, and then "
"e.g. know at least some things that it does in that case. Such "
"specialization would have to be decided if it makes sense. In the "
"alternative, it could be done for each variant anyway, as there won't be "
"that many of them."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3558
msgid ""
"Doing this \"forward\" analysis appears to be best suited for functions "
"and therefore long term. We will try it that way."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3562
msgid "Excursion to Loops"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3577
msgid ""
"The handling of loops (both ``for`` and ``while`` are re-formulated to "
"this kind of loops with ``break`` statements) has its own problem. The "
"loop start and may have an assumption from before it started, that ``a`` "
"is constant, but that is only true for the first iteration. So, we can't "
"pass knowledge from outside loop forward directly into the for loop body."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3584
msgid ""
"So the collection for loops needs to be two pass for loops. First, to "
"collect assignments, and merge these into the start state, before "
"entering the loop body. The need to make two passes is special to loops."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3588
msgid ""
"For a start, it is done like this. At loop entry, all pre-existing, but "
"written traces, are turned into loop merges. Knowledge is not completely "
"removed about everything assigned or changed in the loop, but then it's "
"not trusted anymore."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3593
msgid ""
"From that basis, the ``break`` exits are analysed, and merged, building "
"up the post loop state, and ``continue`` exits of the loop replacing the "
"unknown part of the loop entry state. The loop end is considered a "
"``continue`` for this purpose."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3599
msgid "Excursion to Conditions"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3610
msgid ""
"The above code contains a condition, and these have the problem, that "
"when exiting the conditional block, a merge must be done, of the ``x`` "
"versions. It could be either one. The merge may trace the condition under"
" which a choice is taken. That way, we could decide pairs of traces under"
" the same condition."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3616
msgid ""
"These merges of SSA variable \"versions\", represent alternative values. "
"They pose difficulties, and might have to be reduced to commonality. In "
"the above example, the ``<`` operator will have to check for each "
"version, and then to decide that both indeed give the same result."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3621
msgid ""
"The trace collection tracks variable changes in conditional branches, and"
" then merges the existing state at conditional statement exits."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3626
msgid ""
"A branch is considered \"exiting\" if it is not abortive. Should it end "
"in a ``raise``, ``break``, ``continue``, or ``return``, there is no need "
"to merge that branch, as execution of that branch is terminated."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3630
msgid ""
"Should both branches be abortive, that makes things really simple, as "
"there is no need to even continue."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3633
msgid ""
"Should only one branch exist, but be abortive, then no merge is needed, "
"and the collection can assume after the conditional statement, that the "
"branch was not taken, and continue."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3637
msgid ""
"When exiting both the branches, these branches must both be merged, with "
"their new information."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3640
msgid "In the above case:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3642
msgid ""
"The \"yes\" branch knows variable ``x`` is an ``int`` of constant value "
"``1``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3645
msgid ""
"The \"no\" branch knows variable ``x`` is an ``int`` of constant value "
"``2``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3648
msgid "That might be collapsed to:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3650
msgid "The variable ``x`` is an integer of value in ``(1,2)``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3652
msgid "Given this, we then should be able to precompute the value of this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3658
msgid "The comparison operator can therefore decide and tell:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3660
msgid "The variable ``b`` is a boolean of constant value ``True``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3662
msgid "Were it unable to decide, it would still be able to say:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3664
msgid "The variable ``b`` is a boolean."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3666
msgid ""
"For conditional statements optimization, it's also noteworthy, that the "
"condition is known to pass or not pass the truth check, inside branches, "
"and in the case of non-exiting single branches, after the statement it's "
"not true."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3671
msgid "We may want to take advantage of it. Consider e.g."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3680
msgid ""
"In this case, the knowledge that ``a`` is a list, could be used to "
"generate better code and with the definite knowledge that ``a`` is of "
"type list. With that knowledge the ``append`` attribute call will become "
"the ``list`` built-in type operation."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3686
msgid "Excursion to ``return`` statements"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3688
msgid ""
"The ``return`` statement (like ``break``, ``continue``, ``raise``) is "
"\"aborting\" to control flow. It is always the last statement of "
"inspected block. When there statements to follow it, optimization will "
"remove it as \"dead code\"."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3693
msgid ""
"If all branches of a conditional statement are \"aborting\", the "
"statement is decided \"aborting\" too. If a loop doesn't abort with a "
"break, it should be considered \"aborting\" too."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3698
msgid "Excursion to ``yield`` expressions"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3700
msgid ""
"The ``yield`` expression can be treated like a normal function call, and "
"as such invalidates some known constraints just as much as they do. It "
"executes outside code for an unknown amount of time, and then returns, "
"with little about the outside world known anymore, if it's accessible "
"from there."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3707
msgid "Mixed Types"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3709
msgid "Consider the following inside a function or module:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3718
msgid ""
"A programmer will often not make a difference between ``list`` and "
"``tuple``. In fact, using a ``tuple`` is a good way to express that "
"something won't be changed later, as these are mutable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3724
msgid "Better programming style, would be to use this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3733
msgid ""
"People don't do it, because they dislike the performance hit encountered "
"by the generator expression being used to initialize the tuple. But it "
"would be more consistent, and so Nuitka is using it, and of course one "
"day Nuitka ought to be able to make no difference in performance for it."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3739
msgid ""
"To Nuitka though this means, that if ``cond`` is not predictable, after "
"the conditional statement we may either have a ``tuple`` or a ``list`` "
"type object in ``a``. In order to represent that without resorting to \"I"
" know nothing about it\", we need a kind of ``min``/``max`` operating "
"mechanism that is capable of say what is common with multiple alternative"
" values."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3748
msgid ""
"At this time, we don't really have that mechanism to find the commonality"
" between values."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3752
msgid "Back to \"ctypes\""
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3758
msgid ""
"Coming back to this example, we needed to propagate ``ctypes``, then we "
"can propagate \"something\" from ``ctypes.int`` and then known what this "
"gives with a call and no arguments, so the walk of the nodes, and diverse"
" operations should be addressed by a module friend."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3763
msgid ""
"In case a module friend doesn't know what to do, it needs to say so by "
"default. This should be enforced by a base class and give a warning or "
"note."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3768
msgid "Now to the interface"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3770
msgid "The following is the intended interface:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3772
msgid ""
"Iteration with node methods ``computeStatement`` and "
"``computeExpression``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3775
msgid ""
"These traverse modules and functions (i.e. scopes) and visit everything "
"in the order that Python executes it. The visiting object is "
"``TraceCollection`` and pass forward. Some node types, e.g. "
"``StatementConditional`` new create branch trace collections and handle "
"the SSA merging at exit."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3781
msgid "Replacing nodes during the visit."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3783
msgid ""
"Both ``computeStatement`` and ``computeExpression`` are tasked to return "
"potential replacements of themselves, together with \"tags\" (meaningless"
" now), and a \"message\", used for verbose tracing."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3787
msgid ""
"The replacement node of ``+`` operator, may e.g. be the pre-computed "
"constant result, wrapped in side effects of the node, or the expression "
"raised, again wrapped in side effects."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3791
msgid "Assignments and references affect SSA."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3793
msgid ""
"The SSA tree is initialized every time a scope is visited. Then during "
"traversal, traces are built up. Every assignment and merge starts a new "
"trace for that matter. References to a given variable version are traced "
"that way."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3798
msgid "Value escapes are traced too."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3800
msgid ""
"When an operation hands over a value to outside code, it indicates so to "
"the trace collection. This is for it to know, when e.g. a constant value,"
" might be mutated meanwhile."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3804
msgid "Nodes can be queried about their properties."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3806
msgid ""
"There is a type shape and a value shape that each node can be asked "
"about. The type shape offers methods that allow to check if certain "
"operations are at all supported or not. These can always return ``True`` "
"(yes), ``False`` (no), and ``None`` (cannot decide). In the case of the "
"later, optimizations may not be able do much about it. Lets call these "
"values \"tri-state\"."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3813
msgid ""
"There is also the value shape of a node. This can go deeper, and be more "
"specific to a given node."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3816
msgid ""
"The default implementation will be very pessimistic. Specific node types "
"and shapes may then declare, that they e.g. have no side effects, will "
"not raise for certain operations, have a known truth value, have a known "
"iteration length, can predict their iteration values, etc."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3822
msgid "Nodes are linked to certain states."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3824
msgid ""
"During the collect, a variable reference, is linked to a certain trace "
"state, and that can be used by parent operations."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3832
msgid ""
"In this example, the references to ``a``, can look-up the ``1`` in the "
"trace, and base value shape response to ``+`` on it. For compile time "
"evaluation, it may also ask ``isCompileTimeConstant()`` and if both nodes"
" will respond ``True``, then \"getCompileTimeConstant()\" will return "
"``1``, which will be be used in computation."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3838
msgid ""
"Then ``extractSideEffects()`` for the ``a`` reference will return ``()`` "
"and therefore, the result ``2`` will not be wrapped."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3841
msgid ""
"An alternative approach would be ``hasTypeSlotAdd()`` on the both nodes, "
"and they both do, to see if the selection mechanism used by CPython can "
"be used to find which types ``+`` should be used."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3845
msgid "Class for module import expression ``ExpressionImportModule``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3847
msgid ""
"This one just knows that something is imported, but not how or what it is"
" assigned to. It will be able in a recursive compile, to provide the "
"module as an assignment source, or the module variables or submodules as "
"an attribute source when referenced from a variable trace or in an "
"expression."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3853
msgid "Base class for module friend ``ModuleFriendBase``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3855
msgid ""
"This is intended to provide something to overload, which e.g. can handle "
"``math`` in a better way."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3858
msgid "Module ``ModuleFriendRegistry``"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3860
msgid ""
"Provides a register function with ``name`` and instances of "
"``ValueFriendModuleBase`` to be registered. Recursed to modules should "
"integrate with that too. The registry could well be done with a metaclass"
" approach."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3865
msgid "The module friends should each live in a module of their own."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3867
msgid ""
"With a naming policy to be determined. These modules should add "
"themselves via above mechanism to ``ModuleFriendRegistry`` and all shall "
"be imported and register. Importing of e.g. ``ctypes`` should be delayed "
"to when the friend is actually used. A meta class should aid this task."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3873
msgid ""
"The delay will avoid unnecessary blot of the compiler at run time, if no "
"such module is used. For \"qt\" and other complex stuff, this will be a "
"must."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3877
msgid "The walk should initially be single pass, and not maintain history."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3879
msgid ""
"Instead optimization that needs to look at multiple things, e.g. \"unused"
" assignment\", will look at the whole SSA collection afterwards."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3884
msgid "Discussing with examples"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3886
msgid "The following examples:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3911
msgid ""
"The optimization is mostly performed by walking of the tree and "
"performing trace collection. When it encounters assignments and "
"references to them, it considers current state of traces and uses it for "
"``computeExpression``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3918
msgid ""
"Assignments to attributes, indexes, slices, etc. will also need to follow"
" the flow of ``append``, so it cannot escape attention that a list may be"
" modified. Usages of ``append`` that we cannot be sure about, must be "
"traced to exist, and disallow the list to be considered known value "
"again."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3925
msgid "Code Generation Impact"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3927
msgid ""
"Right now, code generation assumes that everything is a ``PyObject *``, "
"i.e. a Python object, and does not take knowledge of ``int`` or other "
"types into consideration at all, and it should remain like that for some "
"time to come."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3932
msgid ""
"Instead, ``ctypes`` value friend will be asked give ``Identifiers``, like"
" other codes do too. And these need to be able to convert themselves to "
"objects to work with the other things."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3936
msgid ""
"But Code Generation should no longer require that operations must be "
"performed on that level. Imagine e.g. the following calls:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3943
msgid ""
"Value returned by \"other_c_call()\" of say ``c_int`` type, should be "
"possible to be fed directly into another call. That should be easy by "
"having a ``asIntC()`` in the identifier classes, which the ``ctypes`` "
"Identifiers handle without conversions."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3948
msgid ""
"Code Generation should one day also become able to tell that all uses of "
"a variable have only ``c_int`` value, and use ``int`` instead of "
"``PyObjectLocalVariable`` more or less directly. We could consider "
"``PyIntLocalVariable`` of similar complexity as ``int`` after the C++ "
"compiler performed its in-lining."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3954
msgid ""
"Such decisions would be prepared by finalization, which then would track "
"the history of values throughout a function or part of it."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3958
msgid "Initial Implementation"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3960
msgid ""
"The basic interface will be added to *all* expressions and a node may "
"override it, potentially using trace collection state, as attached during"
" ``computeExpression``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3965
msgid "Goal 1 (Reached)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3967
msgid ""
"Initially most things will only be able to give up on about anything. And"
" it will be little more than a tool to do simple look-ups in a general "
"form. It will then be the first goal to turn the following code into "
"better performing one:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3979
msgid "to:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:3988
#: ../../Nuitka-main/Developer_Manual.rst:3997
msgid "and then:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4006
msgid ""
"This depends on SSA form to be able to tell us the values of ``a``, "
"``b``, and ``c`` to be written to by constants, which can be forward "
"propagated at no cost."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4011
msgid "Goal 2 (Reached)"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4013
msgid ""
"The assignments to ``a``, ``b``, and ``c`` shall all become prey to "
"\"unused\" assignment analysis in the next step. They are all only "
"assigned to, and the assignment source has no effect, so they can be "
"simply dropped."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4022
msgid ""
"In the SSA form, these are then assignments without references. These "
"assignments, can be removed if the assignment source has no side effect. "
"Or at least they could be made \"anonymous\", i.e. use a temporary "
"variable instead of the named one. That would have to take into account "
"though, that the old version still needs a release."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4028
msgid ""
"The most general form would first merely remove assignments that have no "
"impact, and leave the value as a side effect, so we arrive at this first:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4039
msgid ""
"When applying the removal of expression only statements without effect, "
"this gives us:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4046
msgid ""
"which is the perfect result. Doing it in one step would only be an "
"optimization at the cost of generalization."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4049
msgid ""
"In order to be able to manipulate nodes related to a variable trace, we "
"need to attach the nodes that did it. Consider this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4062
msgid ""
"In the above case, the merge of the value traces, should say that ``x`` "
"may be undefined, or one of ``1`` or ``3``, but since ``x`` is not used, "
"apply the \"dead value\" trick to each branch."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4066
msgid ""
"The removal of the \"merge\" of the 3 ``x`` versions, should exhibit that"
" the other versions are also only assigned to, and can be removed. These "
"merges of course appear as usages of the ``x`` versions."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4071
msgid "Goal 3"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4073
msgid "Then third goal is to understand all of this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4091
msgid ""
"There are many operations in this, and all of them should be properly "
"handled, or at least ignored in safe way."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4094
msgid ""
"The first goal code gave us that the ``list`` has an annotation from the "
"assignment of ``[]`` and that it will be copied to ``a`` until the for "
"loop in encountered. Then it must be removed, because the ``for`` loop "
"somehow says so."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4099
msgid ""
"The ``a`` may change its value, due to the unknown attribute look-up of "
"it already, not even the call. The for loop must be able to say \"may "
"change value\" due to that, of course also due to the call of that "
"attribute too."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4104
msgid "The code should therefore become equivalent to:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4120
msgid ""
"But no other changes must occur, especially not to the ``return`` "
"statement, it must not assume ``a`` to be constant \"[]\" but an unknown "
"``a`` instead."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4124
msgid ""
"With that, we would handle this code correctly and have some form "
"constant value propagation in place, handle loops at least correctly, and"
" while it is not much, it is important demonstration of the concept."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4129
msgid "Goal 4"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4131
msgid "The fourth goal is to understand the following:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4145
msgid ""
"In this we have a branch, and we will be required to keep track of both "
"the branches separately, and then to merge with the original knowledge. "
"After the conditional statement we will know that \"x\" is an \"int\" "
"with possible values in ``(1,2)``, which can be used to predict that the "
"return value is always ``True``."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4151
msgid ""
"The forth goal will therefore be that the \"ValueFriendConstantList\" "
"knows that append changes ``a`` value, but it remains a list, and that "
"the size increases by one. It should provide an other value friend "
"\"ValueFriendList\" for \"a\" due to that."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4156
msgid "In order to do that, such code must be considered:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4167
msgid ""
"It will be good, if ``len`` still knows that ``a`` is a list object, but "
"not the constant list anymore."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4170
msgid ""
"From here, work should be done to demonstrate the correctness of it with "
"the basic tests applied to discover undetected issues."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4173
msgid ""
"Fifth and optional goal: Extra bonus points for being able to track and "
"predict ``append`` to update the constant list in a known way. Using "
"``list.append`` that should be done and lead to a constant result of "
"``len`` being used."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4178
msgid ""
"The sixth and challenging goal will be to make the code generation be "
"impacted by the value friends types. It should have a knowledge that "
"``PyList_Append`` does the job of append and use ``PyList_Size`` for "
"``len``. The \"ValueFriends\" should aid the code generation too."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4183
msgid ""
"Last and right now optional goal will be to make ``range`` have a value "
"friend, that can interact with iteration of the for loop, and ``append`` "
"of the ``list`` value friend, so it knows it's possible to iterate 5000 "
"times, and that \"a\" has then after the \"loop\" this size, so "
"``len(a)`` could be predicted. For during the loop, about a the range of "
"its length should be known to be less than 5000. That would make the code"
" of goal 2 completely analyzed at compile time."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4192
msgid "Limitations for now"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4194
msgid ""
"Aim only for limited examples. For ``ctypes`` that means to compile time "
"evaluate:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4201
msgid ""
"Later then call to \"libc\" or something else universally available, e.g."
" \"strlen()\" or \"strcmp()\" from full blown declarations of the "
"callable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4205
msgid ""
"We won't have the ability to test that optimization are actually "
"performed, we will check the generated code by hand."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4208
msgid ""
"With time, we will add XML based checks with \"xpath\" queries, expressed"
" as hints, but that is some work that will be based on this work here. "
"The \"hints\" fits into the \"ValueFriends\" concept nicely or so the "
"hope is."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4213
msgid "No inter-function optimization functions yet"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4215
msgid ""
"Of course, once in place, it will make the ``ctypes`` annotation even "
"more usable. Using ``ctypes`` objects inside functions, while creating "
"them on the module level, is therefore not immediately going to work."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4220
msgid "No loops yet"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4222
msgid ""
"Loops break value propagation. For the ``ctypes`` use case, this won't be"
" much of a difficulty. Due to the strangeness of the task, it should be "
"tackled later on at a higher priority."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4226
msgid "Not too much."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4228
msgid ""
"Try and get simple things to work now. We shall see, what kinds of "
"constraints really make the most sense. Understanding ``list`` "
"subscript/slice values e.g. is not strictly useful for much code and "
"should not block us."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4235
msgid "This design is not likely to be the final one."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4239
msgid "How to make Features Experimental"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4241
msgid ""
"Every experimental feature needs a name. We have a rule to pick a name "
"with lower case and ``_`` as separators. An example of with would be the "
"name ``jinja_generated_add`` that has been used in the past."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4246
msgid "Command Line"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4248
msgid "Experimental features are enabled with the command line argument"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4255
msgid "In C code"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4257
msgid ""
"In Scons, all experimental features automatically are converted into C "
"defines, and can be used like this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4268
msgid ""
"The C pre-processor is the only thing that makes an experimental feature "
"usable."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4272
msgid "In Python"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4274
msgid ""
"You can query experimental features using ``Options.isExperimental()`` "
"with e.g. code like this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4285
msgid "When to use it"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4287
msgid ""
"Often we need to keep feature in parallel because they are not finished, "
"or need to be tested after merge and should not break. Then we can do "
"code changes that will not make a difference except when the experimental"
" flag is given on the command line to Nuitka."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4292
msgid ""
"The testing of Nuitka is very heavy weight when e.g. all Python code is "
"compiled, and very often, it is interesting to compare behavior with and "
"without a change."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4297
msgid "When to remove it"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4299
msgid ""
"When a feature becomes default, we might choose to keep the old variant "
"around, but normally we do not. Then we remove the ``if`` and ``#if`` "
"checks and drop the old code."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4303
msgid ""
"At this time, large scale testing will have demonstrated the viability of"
" the code."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4308
msgid "Adding dependencies to Nuitka"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4310
msgid ""
"First of all, there is an important distinction to make, runtime or "
"development time. The first kind of dependency is used when Nuitka is "
"executing."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4315
msgid "Adding a Runtime Dependency"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4317
msgid ""
"This is the kind of dependency that is the most scrutinized. As we want "
"Nuitka to run on latest greatest Python as well as relatively old ones, "
"we have to be very careful with these ones."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4321
msgid ""
"There is also a distinction of optional dependencies. Right now e.g. the "
"``lxml`` package is relatively optional, and Nuitka can work without it "
"being installed, because e.g. on some platforms it will not be easy to do"
" so. That bar has lifted somewhat, but it means e.g. that XML based "
"optimization tests are not run with all Python versions."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4327
msgid ""
"The list of runtime dependencies is in ``requirements.txt`` and it is for"
" those the case, that they are not really required to be installed by the"
" user, consider this snippet:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4339
msgid ""
"For both these dependencies, there is either an inline copy (Scons) that "
"we handle to use in case, if Scons is not available (in fact we have a "
"version that works with Python 2.6 and 2.7 still), and also the same for "
"appdirs and every dependency."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4344
msgid ""
"But since inline copies are against the rules on some platforms that "
"still do not contain the package, we often even have our own wrapper "
"which provides a minimal fallback or exposes a sane interface for the "
"subset of functionality that we use."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4351
msgid ""
"Therefore, please if you consider adding one of these, get in touch with "
"``@Nuitka-pushers`` first and get a green light."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4355
msgid "Adding a Development Dependency"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4357
msgid ""
"A typical example of a development dependency is ``black`` which is used "
"by our autoformat tool, and then in turn by the git pre-commit hook. It "
"is used to format source code, and doesn't have a role at run time of the"
" actual compiler code of Nuitka."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4362
msgid ""
"Much less strict rules apply to these in comparison to runtime "
"dependencies. Generally please take care that the tool must be well "
"maintained an available on newer Pythons. Then we can use it, no problem "
"normally. But if it's really big, say all of SciPy, we might want to "
"justify it a bit better."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4368
msgid ""
"The list of development dependencies is in ``requirements-devel.txt`` and"
" it is for example like this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4376
msgid ""
"We always add the version, so that when tests run on as old versions as "
"Python 2.6, the installation would fail with that version, so we need to "
"make a version requirement. Sometimes we use older versions for Python2 "
"than for Python3, ``Jinaj2`` being a notable candidate, but generally we "
"ought to avoid that. For many tools only being available for currently "
"3.7 or higher is good enough, esp. if they are run as development tools, "
"like ``autoformat-nuitka-source`` is."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4386
msgid "Idea Bin"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4388
msgid ""
"This an area where to drop random ideas on our minds, to later sort it "
"out, and out it into action, which could be code changes, plan changes, "
"issues created, etc."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4392
msgid "Make \"SELECT_METACLASS\" meta class selection transparent."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4394
msgid ""
"Looking at the \"SELECT_METACLASS\" it should become an anonymous helper "
"function. In that way, the optimization process can remove choices at "
"compile time, and e.g. in-line the effect of a meta class, if it is "
"known."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4399
msgid ""
"This of course makes most sense, if we have the optimizations in place "
"that will allow this to actually happen."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4402
msgid "Keeping track of iterations"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4404
msgid ""
"The trace collection trace should become the place, where variables or "
"values track their use state. The iterator should keep track of the "
"\"next()\" calls made to it, so it can tell which value to given in that "
"case."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4409
msgid ""
"That would solve the \"iteration of constants\" as a side effect and it "
"would allow to tell that they can be removed."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4412
msgid "That would mean to go back in the tree and modify it long after."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4421
msgid "It would be sweet if we could recognize that as:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4430
msgid "That trivially becomes:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4441
msgid ""
"When the ``del a`` is examined at the end of scope, or due to another "
"assignment to the same variable, ending the trace, we would have to "
"consider of the ``next`` uses, and retrofit the information that they had"
" no effect."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4453
msgid "Aliasing"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4455
msgid ""
"Each time an assignment is made, an alias is created. A value may have "
"different names."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4465
msgid ""
"If we fail to detect the aliasing nature, we will calculate ``d`` "
"wrongly. We may incref and decref values to trace it."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4468
msgid ""
"Aliasing is automatically traced already in SSA form. The ``b`` is "
"assigned to version of ``a``. So, that should allow to replace it with "
"this:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4478
msgid "Which then will be properly handled."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4480
msgid "Tail recursion optimization."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4482
msgid ""
"Functions that return the results of calls, can be optimized. The "
"Stackless Python does it already."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4485
msgid "Integrate with \"upx\" compression."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4487
msgid "Calling \"upx\" on the created binaries, would be easy."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4489
msgid "In-lining constant \"exec\" and \"eval\"."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4491
msgid ""
"It should be possible to re-formulate at least cases without \"locals\" "
"or \"globals\" given."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4504
msgid "Should become this here:"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4517
msgid "If this holds up, inlining ``exec`` should be relatively easy."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4519
msgid "Original and overloaded built-ins"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4521
msgid ""
"This is about making things visible in the node tree. In Nuitka things "
"that are not visible in the node tree tend to be wrong. We already pushed"
" around information to the node tree a lot."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4525
msgid ""
"Later versions, Nuitka will become able to determine it has to be the "
"original built-in at compile time, then a condition that checks will be "
"optimized away, together with the slow path. Or the other path, if it "
"won't be. Then it will be optimized away, or if doubt exists, it will be "
"correct. That is the goal."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4531
msgid ""
"Right now, the change would mean to effectively disable all built-in call"
" optimization, which is why we don't immediately do it."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4534
msgid ""
"Making the compatible version, will also require a full listing of all "
"built-ins, which is typing work merely, but not needed now. And a way to "
"stop built-in optimization from optimizing built-in calls that it used in"
" a wrap. Probably just some flag to indicate it when it visits it to skip"
" it. That's for later."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4540
msgid ""
"But should we have that both, I figure, we could not raise a "
"``RuntimeError`` error, but just do the correct thing, in all cases. An "
"earlier step may raise ``RuntimeError`` error, when built-in module "
"values are written to, that we don't support."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4547
msgid "Prongs of Action"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4549
msgid ""
"In this chapter, we keep track of prongs of action currently ongoing. "
"This can get detailed and shows things we strive for."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4553
msgid "Builtin optimization"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4555
msgid ""
"Definitely want to get built-in names under full control, so that "
"variable references to module variables do not have a twofold role. "
"Currently they reference the module variable and also the potential "
"built-in as a fallback."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4560
msgid ""
"In terms of generated code size and complexity for modules with many "
"variables and uses of them that is horrible. But ``some_var`` (normally) "
"cannot be a built-in and therefore needs no code to check for that each "
"time."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4565
msgid ""
"This is also critical to getting to whole program optimization. Being "
"certain what is what there on module level, will enable more definitely "
"knowledge about data flows and module interfaces."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4570
msgid "Class Creation Overhead Reduction"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4572
msgid ""
"This is more of a meta goal. Some work for the metaclass has already been"
" done, but that is Python2 only currently. Being able to to decide built-"
"ins and to distinguish between global only variables, and built-ins more "
"clearly will help this a lot."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4577
msgid ""
"In the end, empty classes should be able to be statically converted to "
"calls to ``type`` with static dictionaries. The inlining of class "
"creation function is also needed for this, but on Python3 cannot happen "
"yet."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4583
msgid "Memory Usage at Compile Time"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4585
msgid ""
"We will need to store more and more information in the future. Getting "
"the tree to be tight shaped is therefore an effort, where we will be "
"spending time too."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4589
msgid ""
"The mix-ins prevent slots usage, so lets try and get rid of those. The "
"\"children having\" should become more simple and faster code. I am even "
"thinking of even generating code in the meta class, so it's both optimal "
"and doesn't need that mix-in any more. This is going to be ugly then."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4595
msgid "Coverage Testing"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4597
msgid ""
"And then there is coverage, it should be taken and merged from all Python"
" versions and OSes, but I never managed to merge between Windows and "
"Linux for unknown reasons."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4602
msgid "Python3 Performance"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4604
msgid ""
"The Python3 lock for thread state is making it slower by a lot. I have "
"only experimental code that just ignores the lock, but it likely only "
"works on Linux, and I wonder why there is that lock in the first place."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4608
msgid ""
"Ignoring the locks cannot be good. But what updates that thread state "
"pointer ever without a thread change, and is this what abiflags are about"
" in this context, are there some that allow us to ignore the locks."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4612
msgid ""
"An important bit would be to use a thread state once acquired for as much"
" as possible, currently exception helpers do not accept it as an "
"argument, but that ought to become an option, that way saving and "
"restoring an exception will be much faster, not to mention checking and "
"dropping non interesting, or rewriting exceptions."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4619
msgid "Onefile compression on Windows"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4621
msgid ""
"We need to add compression on that platform too. This should use zstd and"
" probably just needs integration into our build. The Python side already "
"is capable of producing compressed payload."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4626
msgid "Caching of Python level compilation"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4628
msgid ""
"While the C compilation result is already cached with ccache and friends "
"now, we need to also cover our bases and save the resulting node tree of "
"potential expensive optimization on the module level."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4634
msgid "Updates for this Manual"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4636
msgid ""
"This document is written in REST. That is an ASCII format which is "
"readable to human, but easily used to generate PDF or HTML documents."
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4639
msgid ""
"You will find the current source under: "
"https://github.com/Nuitka/Nuitka/blob/develop/Developer_Manual.rst"
msgstr ""

#: ../../Nuitka-main/Developer_Manual.rst:4642
msgid "And the current PDF under: https://nuitka.net/doc/Developer_Manual.pdf"
msgstr ""

#~ msgid "Another one we found useful to collaborate:"
#~ msgstr "另一个我们发现有用的合作："

#~ msgid "Live Share (``ms-vsliveshare.vsliveshare``)"
#~ msgstr ""

#~ msgid "Stable (master branch)"
#~ msgstr ""

#~ msgid "Development (develop branch)"
#~ msgstr ""

#~ msgid ""
#~ "Same as factory, but not integrated "
#~ "as factory normally is, and not "
#~ "rebased all the time. For some "
#~ "branches, they will be rebased as "
#~ "a service when we update develop."
#~ msgstr ""

#~ msgid ""
#~ "Every class and every method **must "
#~ "be documented** via the standard Python"
#~ " delimiters (``\"\"\" ... \"\"\"``) in "
#~ "the usual way."
#~ msgstr ""

#~ msgid "Recursion checks are expensive."
#~ msgstr ""

#~ msgid ""
#~ "If the \"caller\" or the \"called\" "
#~ "can declare that it cannot be "
#~ "called by itself, we could leave "
#~ "it out."
#~ msgstr ""

#~ msgid ""
#~ "TODO: Are they really that expensive?"
#~ " Unnecessary yes, but expensive may "
#~ "not be true."
#~ msgstr ""

