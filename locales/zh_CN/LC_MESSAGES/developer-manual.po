# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Kay Hayen and Nuitka Contributors
# This file is distributed under the same license as the Nuitka the Python
# Compiler package.
# xinetzone <735613050@qq.com>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Nuitka the Python Compiler \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-15 09:52+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: xinetzone <735613050@qq.com>, 2022\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../intl/developer-manual.rst:3
msgid "Developer Manual of Nuitka with instructions geared to changing it"
msgstr ""

#: ../../intl/developer-manual.rst:3
msgid "python,compiler,nuitka,developer"
msgstr ""

#: ../../doc/doc/developer-manual.rst:7
msgid "Nuitka Developer Manual"
msgstr "Nuitka 开发者手册"

#: ../../doc/doc/developer-manual.rst:9
msgid ""
"The purpose of this Developer Manual is to present the current design of "
"Nuitka, the project rules, and the motivations for choices made. It is "
"intended to be a guide to the source code, and to give explanations that "
"don't fit into the source code in comments form."
msgstr "本开发者手册的目的是介绍 Nuitka 的当前设计、项目规则以及所做选择的动机。它旨在成为源代码的指南，并以注释的形式给出不适合源代码的解释。"

#: ../../doc/doc/developer-manual.rst:14
msgid ""
"It should be used as a reference for the process of planning and "
"documenting decisions we made. Therefore we are e.g. presenting here the "
"type inference plans before implementing them. And we update them as we "
"proceed."
msgstr "它应该被用作规划和记录我们所做决定过程的参考。因此，我们在这里，例如，在实施类型推理计划之前，提出了这些计划。而且我们在进行过程中更新它们。"

#: ../../doc/doc/developer-manual.rst:19
msgid ""
"It grows out of discussions and presentations made at conferences as well"
" as private conversations or issue tracker."
msgstr "它是从会议上的讨论和演讲以及私人谈话或问题跟踪器中成长起来的。"

#: ../../doc/doc/developer-manual.rst:24
msgid "Milestones"
msgstr "里程碑"

#: ../../doc/doc/developer-manual.rst:26
msgid ""
"Feature parity with CPython, understand all the language construct and "
"behave absolutely compatible."
msgstr "与 CPython 的功能相当，理解所有的语言构造，行为上绝对兼容。"

#: ../../doc/doc/developer-manual.rst:29
msgid ""
"Feature parity has been reached for CPython 2.6 and 2.7. We do not target"
" any older CPython release. For CPython 3.3 up to 3.8 it also has been "
"reached. We do not target the older and practically unused CPython 3.0 to"
" 3.2 releases."
msgstr ""
"CPython 2.6 和2.7 的功能已经达到平价。我们不针对任何旧的 CPython 版本。对于CPython 3.3 到 "
"3.8，也已经达到了平价。我们不针对旧的、几乎没有使用过的 CPython 3.0 到 3.2 版本。"

#: ../../doc/doc/developer-manual.rst:34
msgid ""
"This milestone was reached. Dropping support for Python 2.6 and 3.3 is an"
" option, should this prove to be any benefit. Currently it is not, as it "
"extends the test coverage only."
msgstr "这个里程碑已经达成。放弃对 Python 2.6 和 3.3 的支持是一种选择，如果这被证明有任何好处的话。目前还没有，因为它只扩展了测试范围。"

#: ../../doc/doc/developer-manual.rst:38
msgid ""
"Create the most efficient native code from this. This means to be fast "
"with the basic Python object handling."
msgstr "从中创建最有效的本地代码。这意味着要在基本的 Python 对象处理方面做到快速。"

#: ../../doc/doc/developer-manual.rst:41
msgid ""
"This milestone was reached, although of course, micro optimizations to "
"this are happening all the time."
msgstr "这个里程碑已经达成，当然，对此的微观优化一直在进行。"

#: ../../doc/doc/developer-manual.rst:44
msgid ""
"Then do constant propagation, determine as many values and useful "
"constraints as possible at compile time and create more efficient code."
msgstr "然后做 constant 传播，在编译时确定尽可能多的值和有用的约束，并创建更有效的代码。"

#: ../../doc/doc/developer-manual.rst:48
msgid ""
"This milestone is considered almost reached. We continue to discover new "
"things, but the infrastructure is there, and these are easy to add."
msgstr "这个里程碑被认为几乎达到了。我们继续发现新的东西，但基础设施已经存在，这些都很容易添加。"

#: ../../doc/doc/developer-manual.rst:52
msgid ""
"Type inference, detect and special case the handling of strings, "
"integers, lists in the program."
msgstr "类型推理，检测和特例处理程序中的字符串、整数、列表。"

#: ../../doc/doc/developer-manual.rst:55
msgid "This milestone is considered in progress."
msgstr "这个里程碑被认为是正在进行中。"

#: ../../doc/doc/developer-manual.rst:57
msgid ""
"Add interfacing to C code, so Nuitka can turn a ``ctypes`` binding into "
"an efficient binding as written with C."
msgstr "增加与 C 代码的接口，所以 Nuitka 可以把 ``ctypes`` 的绑定变成用 C 编写的有效绑定。"

#: ../../doc/doc/developer-manual.rst:60 ../../doc/doc/developer-manual.rst:65
msgid "This milestone is planned only."
msgstr "这个里程碑只是计划中的。"

#: ../../doc/doc/developer-manual.rst:62
msgid ""
"Add hints module with a useful Python implementation that the compiler "
"can use to learn about types from the programmer."
msgstr "增加提示模块，有一个有用的 Python 实现，编译器可以用它来向程序员学习类型。"

#: ../../doc/doc/developer-manual.rst:69
msgid "Version Numbers"
msgstr "版本数字"

#: ../../doc/doc/developer-manual.rst:71
msgid ""
"For Nuitka we use semantic versioning, initially with a leading zero "
"still, once we pass release ``0.9``, the scheme will indicate the ``10`` "
"through using ``1.0``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:77
msgid "Current State"
msgstr "当前状态"

#: ../../doc/doc/developer-manual.rst:79
msgid "Nuitka top level works like this:"
msgstr "Nuitka 顶层的工作是这样的："

#: ../../doc/doc/developer-manual.rst:81
msgid "``nuitka.tree.Building`` outputs node tree"
msgstr "``nuitka.tree.Building`` 输出节点树"

#: ../../doc/doc/developer-manual.rst:83
msgid "``nuitka.optimization`` enhances it as best as it can"
msgstr "``nuitka.optimization`` 尽可能地增强它"

#: ../../doc/doc/developer-manual.rst:85
msgid "``nuitka.finalization`` prepares the tree for code generation"
msgstr "``nuitka.finalization`` 为代码生成准备好树"

#: ../../doc/doc/developer-manual.rst:87
msgid ""
"``nuitka.codegen.CodeGeneration`` orchestrates the creation of code "
"snippets"
msgstr "``nuitka.codegen.CodeGeneration`` 协调代码片断的创建"

#: ../../doc/doc/developer-manual.rst:90
msgid "``nuitka.codegen.*Codes`` knows how specific code kinds are created"
msgstr "``nuitka.codegen.*Codes`` 知道具体的代码种类是如何产生的"

#: ../../doc/doc/developer-manual.rst:92
msgid "``nuitka.MainControl`` keeps it all together"
msgstr "``nuitka.MainControl`` 保持一致"

#: ../../doc/doc/developer-manual.rst:94
msgid "This design is intended to last."
msgstr "这种设计的目的是为了持久。"

#: ../../doc/doc/developer-manual.rst:96
msgid "Regarding types, the state is:"
msgstr "关于类型，状态是："

#: ../../doc/doc/developer-manual.rst:98
msgid ""
"Types are always ``PyObject *``, and only a few C types, e.g. "
"``nuitka_bool`` and ``nuitka_void`` and more are coming. Even for "
"objects, often it's know that things are e.g. really a ``PyTupleObject "
"**``, but no C type is available for that yet."
msgstr ""
"类型总是 ``PyObject *``，只有少数 C 类型，例如 ``nuitka_bool`` 和 "
"``nuitka_void``，更多的类型正在到来。即使是对象，也经常知道事物是例如 ``PyTupleObject **``，但还没有 C "
"类型可用于此。"

#: ../../doc/doc/developer-manual.rst:103
msgid ""
"There are a some specific use of types beyond \"compile time constant\", "
"that are encoded in type and value shapes, which can be used to predict "
"some operations, conditions, etc. if they raise, and result types they "
"give."
msgstr ""
"有一些特定的使用类型超越了 "
"\"编译时间常量\"，这些类型在类型和值的形状中被编码，可以用来预测一些操作、条件等，如果他们提出，以及他们给出的结果类型。"

#: ../../doc/doc/developer-manual.rst:108
msgid ""
"In code generation, the supported C types are used, and sometimes we have"
" specialized code generation, e.g. a binary operation that takes an "
"``int`` and a ``float`` and produces a ``float`` value. There will be "
"fallbacks to less specific types."
msgstr ""
"在代码生成中，使用支持的 C 类型，有时我们会有专门的代码生成，例如，一个二进制操作需要一个 ``int`` 和一个 ``float`` "
"并产生一个 ``float`` 值。将会有回落到不太具体的类型。"

#: ../../doc/doc/developer-manual.rst:113
msgid ""
"The expansion with more C types is currently in progress, and there will "
"also be alternative C types, where e.g. ``PyObject *`` and ``C long`` are"
" in an enum that indicates which value is valid, and where special code "
"will be available that can avoid creating the ``PyObject **`` unless the "
"later overflows."
msgstr ""
"目前正在用更多的 C 类型进行扩展，也会有替代的 C 类型，例如 ``PyObject *`` 和 ``C long`` "
"在一个枚举中，表明哪个值是有效的，而且会有特殊的代码，可以避免创建 ``PyObject **``，除非后来的溢出。"

#: ../../doc/doc/developer-manual.rst:121
msgid "Setting up the Development Environment for Nuitka"
msgstr "为 Nuitka 设置开发环境"

#: ../../doc/doc/developer-manual.rst:123
msgid ""
"Currently there are very different kinds of files that we need support "
"for. This is best addressed with an IDE. We cover here how to setup the "
"most common one."
msgstr "目前，我们需要支持极其不同种类的文件。这一点最好用 IDE 来解决。我们在这里介绍如何设置最常见的文件。"

#: ../../doc/doc/developer-manual.rst:128
msgid "Visual Studio Code"
msgstr ""

#: ../../doc/doc/developer-manual.rst:130
msgid ""
"Download Visual Studio Code from here: "
"https://code.visualstudio.com/download"
msgstr "从这里下载 Visual Studio Code：https://code.visualstudio.com/download"

#: ../../doc/doc/developer-manual.rst:133
msgid ""
"At this time, this is the recommended IDE for Linux and Windows. This is "
"going to cover the plugins to install. Configuration is part of the "
"``.vscode`` in your Nuitka checkout. If you are not familiar with "
"Eclipse, this is Free Software IDE,designed to be universally extended, "
"and it truly is. There are plugins available for nearly everything."
msgstr ""
"目前，这是推荐用于 Linux 和 Windows 的 IDE。这将涵盖要安装的插件。配置是你的 Nuitka 检出中的 ``.vscode`` "
"的一部分。如果你不熟悉 Eclipse，这是一个自由软件 IDE，被设计成可以普遍扩展的，而且它确实如此。几乎所有的东西都有插件可用。"

#: ../../doc/doc/developer-manual.rst:139
msgid ""
"The extensions to be installed are part of the Visual Code "
"recommendations in ``.vscode/extensions.json`` and you will be prompted "
"about that and ought to install these."
msgstr ""
"要安装的扩展是 Visual Code 建议的一部分，在 ``.vscode/extensions.json`` "
"中，你会被提示到这一点，应该安装这些。"

#: ../../doc/doc/developer-manual.rst:144
msgid "Eclipse / PyCharm"
msgstr ""

#: ../../doc/doc/developer-manual.rst:146
msgid ""
"Don't use these anymore, we consider Visual Studio Code to be far "
"superior for delivering a nice out of the box environment."
msgstr "不要再使用这些了，我们认为 Visual Studio Code 在提供一个良好的开箱即用环境方面要优越得多。"

#: ../../doc/doc/developer-manual.rst:151
msgid "Commit and Code Hygiene"
msgstr "承诺和守则的卫士"

#: ../../doc/doc/developer-manual.rst:153
#, fuzzy
msgid ""
"In Nuitka we have tools to auto format code, you can execute them "
"manually, but it's probably best to execute them at commit time, to make "
"sure when we share code, it's already well format, and to avoid noise "
"doing cleanups."
msgstr ""
"在 Nuitka "
"中，我们有自动格式化代码的工具，你可以手动执行，但最好是在提交时执行，以确保当我们分享代码时，它已经被很好地格式化了，并避免做清理的噪音。"

#: ../../doc/doc/developer-manual.rst:158
#, fuzzy
msgid ""
"The kinds of changes also often cause unnecessary merge conflicts, while "
"the auto format is designed to format code also in a way that it avoids "
"merge conflicts in the normal case, e.g. by doing imports one item per "
"line."
msgstr "这类修改也经常引起不必要的合并冲突，而自动格式化的设计也是为了在正常情况下避免合并冲突，比如说每行做导入一项，就可以避免合并冲突。"

#: ../../doc/doc/developer-manual.rst:163
msgid "In order to set up hooks, you need to execute these commands:"
msgstr "为了设置钩子，你需要执行这些命令："

#: ../../doc/doc/developer-manual.rst:172
msgid ""
"These commands will make sure that the ``autoformat-nuitka-source`` is "
"run on every staged file content at the time you do the commit. For C "
"files, it may complain unavailability of ``clang-format``, follow it's "
"advice. You may call the above tool at all times, without arguments to "
"format call Nuitka source code."
msgstr ""
"这些命令将确保 ``autoformat-nuitka-source`` 在你做提交的时候对每个阶段性的文件内容运行。对于 C 文件，它可能会抱怨"
" ``clang-format`` 不可用，请遵循它的建议。你可以在任何时候调用上述工具，不需要参数就可以格式化调用 Nuitka 源代码。"

#: ../../doc/doc/developer-manual.rst:178
msgid ""
"Should you encounter problems with applying the changes to the checked "
"out file, you can always execute it with ``COMMIT_UNCHECKED=1`` "
"environment set."
msgstr "如果你在将修改应用到检查出来的文件时遇到问题，你总是可以在 ``COMMIT_UNCHECKED=1`` 的环境设置下执行它。"

#: ../../doc/doc/developer-manual.rst:184
msgid "Coding Rules Python"
msgstr "Python 编码规则"

#: ../../doc/doc/developer-manual.rst:186
msgid ""
"These rules should generally be adhered when working on Nuitka code. It's"
" not library code and it's optimized for readability, and avoids all "
"performance optimization for itself."
msgstr "在 Nuitka 代码上工作时，一般应遵守这些规则。它不是库的代码，而且它是为了可读性而优化的，避免了对自己的所有性能优化。"

#: ../../doc/doc/developer-manual.rst:191
msgid "Tool to format"
msgstr ""

#: ../../doc/doc/developer-manual.rst:193
msgid ""
"There is a tool ``bin/autoformat-nuitka-source`` which is to apply "
"automatic formatting to code as much as possible. It uses ``black`` "
"(internally) for consistent code formatting. The imports are sorted with "
"``isort`` for proper order."
msgstr ""

#: ../../doc/doc/developer-manual.rst:198
msgid ""
"The tool (mostly ``black`` and ``isort``) encodes all formatting rules, "
"and makes the decisions for us. The idea being that we can focus on "
"actual code and do not have to care as much about other things. It also "
"deals with Windows new lines, trailing space, etc. and even sorts PyLint "
"disable statements."
msgstr ""

#: ../../doc/doc/developer-manual.rst:205
msgid "Identifiers"
msgstr ""

#: ../../doc/doc/developer-manual.rst:207
msgid ""
"Classes are camel case with leading upper case. Functions and methods are"
" with leading verb in lower case, but also camel case. Variables and "
"arguments are lower case with ``_`` as a separator."
msgstr ""

#: ../../doc/doc/developer-manual.rst:217
msgid ""
"Base classes that are abstract have their name end with ``Base``, so that"
" a meta class can use that convention, and readers immediately know, that"
" it will not be instantiated like that."
msgstr ""

#: ../../doc/doc/developer-manual.rst:221
msgid ""
"Function calls use keyword argument preferably. These are slower in "
"CPython, but more readable:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:230
msgid "When the names don't add much value, sequential calls can be done:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:236
msgid ""
"Here, ``setLoopContinueTarget`` will be so well known that the reader is "
"expected to know the argument names and their meaning, but it would be "
"still better to add them. But in this instance, the variable name already"
" indicates that it is."
msgstr ""

#: ../../doc/doc/developer-manual.rst:242
msgid "Module/Package Names"
msgstr ""

#: ../../doc/doc/developer-manual.rst:244
msgid ""
"Normal modules are named in camel case with leading upper case, because "
"of their role as singleton classes. The difference between a module and a"
" class is small enough and in the source code they are also used "
"similarly."
msgstr ""

#: ../../doc/doc/developer-manual.rst:249
msgid ""
"For the packages, no real code is allowed in their ``__init__.py`` and "
"they must be lower case, like e.g. ``nuitka`` or ``codegen``. This is to "
"distinguish them from the modules."
msgstr ""

#: ../../doc/doc/developer-manual.rst:253
msgid ""
"Packages shall only be used to group things. In ``nuitka.codegen`` the "
"code generation packages are located, while the main interface is "
"``nuitka.codegen.CodeGeneration`` and may then use most of the entries as"
" local imports."
msgstr ""

#: ../../doc/doc/developer-manual.rst:258
msgid ""
"There is no code in packages themselves. For programs, we use "
"``__main__`` package to carry the actual code."
msgstr ""

#: ../../doc/doc/developer-manual.rst:261
msgid ""
"Names of modules should be plurals if they contain classes. Example is "
"that a ``Nodes`` module that contains a ``Node`` class."
msgstr ""

#: ../../doc/doc/developer-manual.rst:265
msgid "Names for context manages start with ``with``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:267
msgid ""
"In order to easily recognize that something is to be used as a context "
"manager, we follow a pattern of naming them ``withSomething``, to make "
"that easily recognized."
msgstr ""

#: ../../doc/doc/developer-manual.rst:277
msgid "This makes these easy to recognize even in their definition."
msgstr ""

#: ../../doc/doc/developer-manual.rst:280
msgid "Prefer list contractions over built-ins"
msgstr ""

#: ../../doc/doc/developer-manual.rst:282
msgid ""
"This concerns ``map``, ``filter``, and ``apply``. Usage of these built-"
"ins is highly discouraged within Nuitka source code. Using them is "
"considered worth a warning by \"PyLint\" e.g. \"Used built-in function "
"'map'\". We should use list contractions instead, because they are more "
"readable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:288
msgid ""
"List contractions are a generalization for all of them. We love "
"readability and with Nuitka as a compiler, there won't be any performance"
" difference at all."
msgstr ""

#: ../../doc/doc/developer-manual.rst:292
msgid ""
"There are cases where a list contraction is faster because you can avoid "
"to make a function call. And there may be cases, where map is faster, if "
"a function must be called. These calls can be very expensive in CPython, "
"and if you introduce a function, just for ``map``, then it might be "
"slower."
msgstr ""

#: ../../doc/doc/developer-manual.rst:298
msgid ""
"But of course, Nuitka is the project to free us from what is faster and "
"to allow us to use what is more readable, so whatever is faster, we don't"
" care. We make all options equally fast and let people choose."
msgstr ""

#: ../../doc/doc/developer-manual.rst:302
msgid ""
"For Nuitka the choice is list contractions as these are more easily "
"changed and readable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:305
msgid "Look at this code examples from Python:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:324
msgid ""
"This pretty much is what makes properties bad. One would hope ``B().x`` "
"to be ``2``, but instead it's not changed. Because of the way properties "
"take the functions and not members, and because they then are not part of"
" the class, they cannot be overloaded without re-declaring them."
msgstr ""

#: ../../doc/doc/developer-manual.rst:329
msgid ""
"Overloading is then not at all obvious anymore. Now imagine having a "
"setter and only overloading the getter. How to update the property "
"easily?"
msgstr ""

#: ../../doc/doc/developer-manual.rst:333
msgid ""
"So, that's not likable about them. And then we are also for clarity in "
"these internal APIs too. Properties try and hide the fact that code needs"
" to run and may do things. So let's not use them."
msgstr ""

#: ../../doc/doc/developer-manual.rst:337
msgid ""
"For an external API you may exactly want to hide things, but internally "
"that has no use, and in Nuitka, every API is internal API. One exception "
"may be the ``hints`` module, which will gladly use such tricks for an "
"easier write syntax."
msgstr ""

#: ../../doc/doc/developer-manual.rst:344
msgid "Coding Rules C"
msgstr ""

#: ../../doc/doc/developer-manual.rst:346
msgid ""
"For the static C parts, e.g. compiled types, helper codes, the ``clang-"
"format`` from LLVM project is used, the tool ``autoformat-nuitka-source``"
" does this for us."
msgstr ""

#: ../../doc/doc/developer-manual.rst:350
msgid ""
"We always have blocks for conditional statements to avoid typical "
"mistakes made by adding a statement to a branch, forgetting to make it a "
"block."
msgstr ""

#: ../../doc/doc/developer-manual.rst:356
msgid "The \"git flow\" model"
msgstr ""

#: ../../doc/doc/developer-manual.rst:358
msgid "The flow is used for releases and occasionally subsequent hot fixes."
msgstr ""

#: ../../doc/doc/developer-manual.rst:360
msgid ""
"A few feature branches were used so far. It allows for quick delivery of "
"fixes to both the stable and the development version, supported by a git "
"plug-in, that can be installed via \"apt-get install git-flow\"."
msgstr ""

#: ../../doc/doc/developer-manual.rst:364
msgid "Stable (``main`` branch)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:366
msgid ""
"The stable version, is expected to pass all the tests at all times and is"
" fully supported. As soon as bugs are discovered, they are fixed as hot "
"fixes, and then merged to develop by the \"git flow\" automatically."
msgstr ""

#: ../../doc/doc/developer-manual.rst:371
msgid "Development (``develop`` branch)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:373
msgid ""
"The future release, supposedly in almost ready for release state at "
"nearly all times, but this is as strict. It is not officially supported, "
"and may have problems and at times inconsistencies. Normally this branch "
"is supposed to not be rebased. For severe problems it may be done though."
msgstr ""

#: ../../doc/doc/developer-manual.rst:379
msgid "Factory (default feature branch)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:381
msgid ""
"Code under construction. We publish commits there, that may not hold up "
"in testing, and before it enters develop branch. Factory may have severe "
"regressions frequently, and commits become **rebased all the time**, so "
"do not base your patches on it, please prefer the ``develop`` branch for "
"that, unless of course, it's about factory code itself."
msgstr ""

#: ../../doc/doc/developer-manual.rst:388
msgid "Personal branches (jorj, orsiris, others as well)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:390
msgid "We are currently not using this, but it's an option."
msgstr ""

#: ../../doc/doc/developer-manual.rst:392
msgid "Feature Branches"
msgstr ""

#: ../../doc/doc/developer-manual.rst:394
msgid ""
"We are not currently using these. They could be used for long lived "
"changes that extend for multiple release cycles and are not ready yet. "
"Currently we perform all changes in steps that can be included in "
"releases or delay making those changes."
msgstr ""

#: ../../doc/doc/developer-manual.rst:401
msgid "Nuitka \"git/github\" Workflow"
msgstr ""

#: ../../doc/doc/developer-manual.rst:403
msgid "Forking and cloning"
msgstr ""

#: ../../doc/doc/developer-manual.rst:405
msgid ""
"You need to have git installed and GitHub account. Goto Nuitka repository"
" <https://github.com/Nuitka/Nuitka> and fork the repository."
msgstr ""

#: ../../doc/doc/developer-manual.rst:409
msgid "To clone it to your local machine execute the following your git bash:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:418
msgid "Create a Branch"
msgstr ""

#: ../../doc/doc/developer-manual.rst:426
msgid ""
"If you are having merge conflicts while doing the previous step, then "
"check out (DON'T FORGET TO SAVE YOUR CHANGES FIRST IF ANY): "
"<https://stackoverflow.com/questions/1125968/how-do-i-force-git-pull-to-"
"overwrite-local-files>"
msgstr ""

#: ../../doc/doc/developer-manual.rst:430
msgid "In case you have an existing branch rebase it to develop"
msgstr ""

#: ../../doc/doc/developer-manual.rst:437
msgid "Fix the merge conflicts if any, stash them and continue:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:443
msgid "If anything goes wrong while rebasing:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:449
msgid "Making changes"
msgstr ""

#: ../../doc/doc/developer-manual.rst:459
msgid "API Documentation and Guidelines"
msgstr ""

#: ../../doc/doc/developer-manual.rst:461
msgid ""
"There is API documentation generated with ``doxygen``, available at `this"
" location <https://nuitka.net/apidoc>`__ ."
msgstr ""

#: ../../doc/doc/developer-manual.rst:464
msgid ""
"To ensure meaningful ``doxygen`` output, the following guidelines must be"
" observed when creating or updating Python source:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:468
msgid "Use of Standard Python ``__doc__`` Strings"
msgstr ""

#: ../../doc/doc/developer-manual.rst:470
msgid ""
"Every class and every method should be documented via the standard Python"
" delimiters (``\"\"\" ... \"\"\"``) in the usual way."
msgstr ""

#: ../../doc/doc/developer-manual.rst:474
msgid "Special ``doxygen`` Anatomy of ``__doc__``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:478
msgid "We are replacing Doxygen with sphinx, this is all obsolete"
msgstr ""

#: ../../doc/doc/developer-manual.rst:480
msgid ""
"Immediately after the leading ``\"\"\"``, and after 1 space on the same "
"line, enter a brief description or title of the class or method. This "
"must be 1 line and be followed by at least 1 empty line."
msgstr ""

#: ../../doc/doc/developer-manual.rst:484
msgid ""
"Depending on the item, choose from the following \"sections\" to describe"
" what the item is and does."
msgstr ""

#: ../../doc/doc/developer-manual.rst:487
msgid ""
"Each section name is coded on its own line, aligned with the leading "
"``\"\"\"`` and followed by a colon \":\". Anything following the section,"
" must start on a new line and be indented by 4 spaces relative to the "
"section. Except for the first section (``Notes:``) after the title, "
"sections need not be preceded by empty lines -- but it is good practice "
"to still do that."
msgstr ""

#: ../../doc/doc/developer-manual.rst:494
msgid "``Notes:`` detailed description of the item, any length."
msgstr ""

#: ../../doc/doc/developer-manual.rst:496
msgid ""
"May contain line breaks with each new line starting aligned with previous"
" one. The text will automatically be joined across line breaks and be "
"reformatted in the browser."
msgstr ""

#: ../../doc/doc/developer-manual.rst:500
msgid ""
"If you describe details for a class, you can do so **without** using this"
" section header and all formatting will still work fine. If you however "
"omit the ``Notes:`` for methods, then the text will be interpreted **as "
"code**, be shown in an ugly monospaced font, and no automatic line breaks"
" will occur in the browser."
msgstr ""

#: ../../doc/doc/developer-manual.rst:506
msgid "``Args:`` positional arguments."
msgstr ""

#: ../../doc/doc/developer-manual.rst:508
msgid ""
"Each argument then follows, starting on a new line and indented by 4 "
"spaces. The argument name must be followed by a colon ``:`` or double "
"hash ``--``, followed by a description of arbitrary length."
msgstr ""

#: ../../doc/doc/developer-manual.rst:512
msgid "The description can be separated by line breaks."
msgstr ""

#: ../../doc/doc/developer-manual.rst:514
msgid "``Kwargs:`` keyword arguments. Same rules as for args."
msgstr ""

#: ../../doc/doc/developer-manual.rst:516
msgid ""
"``Returns:`` description of what will be returned if applicable (any "
"length)."
msgstr ""

#: ../../doc/doc/developer-manual.rst:519
msgid "``Yields:`` synonymous for ``Returns:``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:521
msgid "``Raises:`` name any exceptions that may be raised."
msgstr ""

#: ../../doc/doc/developer-manual.rst:523
msgid "``Examples:`` specify any example code."
msgstr ""

#: ../../doc/doc/developer-manual.rst:555
msgid "Checking the Source"
msgstr ""

#: ../../doc/doc/developer-manual.rst:557
msgid ""
"The static checking for errors is currently done with ``PyLint``. In the "
"future, Nuitka itself will gain the ability to present its findings in a "
"similar way, but this is not a priority, and we are not there yet."
msgstr ""

#: ../../doc/doc/developer-manual.rst:561
msgid "So, we currently use ``PyLint`` with options defined in a script."
msgstr ""

#: ../../doc/doc/developer-manual.rst:567
msgid ""
"The above command is expected to give no warnings. It is also run on our "
"CI and we will not merge branches that do not pass."
msgstr ""

#: ../../doc/doc/developer-manual.rst:572
msgid "Running the Tests"
msgstr ""

#: ../../doc/doc/developer-manual.rst:574
msgid "This section describes how to run Nuitka tests."
msgstr ""

#: ../../doc/doc/developer-manual.rst:577
msgid "Running all Tests"
msgstr ""

#: ../../doc/doc/developer-manual.rst:579
msgid "The top level access to the tests is as simple as this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:585
msgid "For fine grained control, it has the following options:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:679
msgid ""
"You will only run the CPython test suites, if you have the submodules of "
"the Nuitka git repository checked out. Otherwise, these will be skipped "
"with a warning that they are not available."
msgstr ""

#: ../../doc/doc/developer-manual.rst:683
msgid ""
"The policy is generally, that ``./test/run-tests`` running and passing "
"all the tests on Linux and Windows shall be considered sufficient for a "
"release, but of course, depending on changes going on, that might have to"
" be expanded."
msgstr ""

#: ../../doc/doc/developer-manual.rst:689
msgid "Basic Tests"
msgstr ""

#: ../../doc/doc/developer-manual.rst:691
msgid "You can run the \"basic\" tests like this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:697
msgid ""
"These tests normally give sufficient coverage to assume that a change is "
"correct, if these \"basic\" tests pass. The most important constructs and"
" built-ins are exercised."
msgstr ""

#: ../../doc/doc/developer-manual.rst:701
msgid ""
"To control the Python version used for testing, you can set the "
"``PYTHON`` environment variable to e.g. ``python3.5`` (can also be full "
"path), or simply execute the ``run_all.py`` script directly with the "
"intended version, as it is portable across all supported Python versions,"
" and defaults testing with the Python version is run with."
msgstr ""

#: ../../doc/doc/developer-manual.rst:708
msgid "Syntax Tests"
msgstr ""

#: ../../doc/doc/developer-manual.rst:710
msgid ""
"Then there are \"syntax\" tests, i.e. language constructs that need to "
"give a syntax error."
msgstr ""

#: ../../doc/doc/developer-manual.rst:713
msgid ""
"It sometimes so happens that Nuitka must do this itself, because the "
"``ast.parse`` doesn't see the problem and raises no ``SyntaxError`` of "
"its own. These cases are then covered by tests to make sure they work as "
"expected."
msgstr ""

#: ../../doc/doc/developer-manual.rst:718
msgid ""
"Using the ``global`` statement on a function argument is an example of "
"this. These tests make sure that the errors of Nuitka and CPython are "
"totally the same for this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:727
msgid "Program Tests"
msgstr ""

#: ../../doc/doc/developer-manual.rst:729
msgid ""
"Then there are small \"programs\" tests, that e.g. exercise many kinds of"
" import tricks and are designed to reveal problems with inter-module "
"behavior. These can be run like this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:738
msgid "Generated Tests"
msgstr ""

#: ../../doc/doc/developer-manual.rst:740
msgid ""
"There are tests, which are generated from Jinja2 templates. They aim at "
"e.g. combining at types with operations, in-place or not, or large "
"constants. These can be run like this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:749
msgid "Compile Nuitka with Nuitka"
msgstr ""

#: ../../doc/doc/developer-manual.rst:751
msgid ""
"And there is the \"compile itself\" or \"reflected\" test. This test "
"makes Nuitka compile itself and compare the resulting C++ when running "
"compiled to non-compiled, which helps to find in-determinism."
msgstr ""

#: ../../doc/doc/developer-manual.rst:755
msgid ""
"The test compiles every module of Nuitka into an extension module and all"
" of Nuitka into a single binary."
msgstr ""

#: ../../doc/doc/developer-manual.rst:758
msgid ""
"That test case also gives good coverage of the ``import`` mechanisms, "
"because Nuitka uses a lot of packages and imports between them."
msgstr ""

#: ../../doc/doc/developer-manual.rst:767
msgid "Internal/Plugin API"
msgstr ""

#: ../../doc/doc/developer-manual.rst:769
msgid ""
"The documentation from the source code for both the Python and the C "
"parts are published as `Nuitka API <https://nuitka.net/apidoc>`__ and "
"arguably in a relatively bad shape as we started generating those with "
"Doxygen only relatively late."
msgstr ""

#: ../../doc/doc/developer-manual.rst:779
msgid ""
"Improvements have already been implemented for plugins: The plugin base "
"class defined in ``PluginBase.py`` (which is used as a template for all "
"plugins) is fully documented in Doxygen now. The same is true for the "
"recently added standard plugins ``NumpyPlugin.py`` and "
"``TkinterPlugin.py``. These will be uploaded very soon."
msgstr ""

#: ../../doc/doc/developer-manual.rst:785
msgid "Going forward, this will also happen for the remaining standard plugins."
msgstr ""

#: ../../doc/doc/developer-manual.rst:787
msgid ""
"Please find `here <https://github.com/Nuitka/Nuitka/blob/develop"
"/UserPlugin-Creation.rst>`__ a detailed description of how to write your "
"own plugin."
msgstr ""

#: ../../doc/doc/developer-manual.rst:791
msgid ""
"To learn about plugin option specification consult `this document "
"<https://github.com/Nuitka/Nuitka/blob/develop/Using-Plugin-"
"Options.rst>`__."
msgstr ""

#: ../../doc/doc/developer-manual.rst:796
msgid "Working with the CPython suites"
msgstr ""

#: ../../doc/doc/developer-manual.rst:798
msgid ""
"The CPython test suites are different branches of the same submodule. "
"When you update your git checkout, they will frequently become detached. "
"In this case, simply execute this command:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:807
msgid "When adding a test suite, for a new version, proceed like this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:863
msgid "Design Descriptions"
msgstr ""

#: ../../doc/doc/developer-manual.rst:865
msgid ""
"These should be a lot more and contain graphics from presentations given."
" It will be filled in, but not now."
msgstr ""

#: ../../doc/doc/developer-manual.rst:869
msgid "Nuitka Logo"
msgstr ""

#: ../../doc/doc/developer-manual.rst:871
msgid ""
"The logo was submitted by \"dr. Equivalent\". It's source is contained in"
" ``doc/Logo`` where 3 variants of the logo in SVG are placed."
msgstr ""

#: ../../doc/doc/developer-manual.rst:874
msgid "Symbol only (symbol)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:881
msgid "Text next to symbol (horizontal)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:888
msgid "Text beneath symbol (vertical)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:895
msgid "From these logos, PNG images, and \"favicons\", and are derived."
msgstr ""

#: ../../doc/doc/developer-manual.rst:897
msgid ""
"The exact ImageMagick commands are in "
"``nuitka/tools/release/Documentation``, but are not executed each time, "
"the commands are also replicated here:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:912
msgid "Choice of the Target Language"
msgstr ""

#: ../../doc/doc/developer-manual.rst:914
msgid "Choosing the target language was important decision. factors were:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:916
msgid "The portability of Nuitka is decided here"
msgstr ""

#: ../../doc/doc/developer-manual.rst:917
msgid "How difficult is it to generate the code?"
msgstr ""

#: ../../doc/doc/developer-manual.rst:918
msgid "Does the Python C-API have bindings?"
msgstr ""

#: ../../doc/doc/developer-manual.rst:919
msgid "Is that language known?"
msgstr ""

#: ../../doc/doc/developer-manual.rst:920
msgid "Does the language aid to find bugs?"
msgstr ""

#: ../../doc/doc/developer-manual.rst:922
msgid ""
"The *decision for C11* is ultimately one for portability, general "
"knowledge of the language and for control over created code, e.g. being "
"able to edit and try that quickly."
msgstr ""

#: ../../doc/doc/developer-manual.rst:926
msgid ""
"The current status is to use pure C11. All code compiles as C11, and also"
" in terms of workaround to missing compiler support as C++03. This is "
"mostly needed, because MSVC does not support C. Naturally we are not "
"using any C++ features, just the allowances of C++ features that made it "
"into C11, which is e.g. allowing late definitions of variables."
msgstr ""

#: ../../doc/doc/developer-manual.rst:933
msgid "Use of Scons internally"
msgstr ""

#: ../../doc/doc/developer-manual.rst:935
msgid ""
"Nuitka does not involve Scons in its user interface at all; Scons is "
"purely used internally. Nuitka itself, being pure Python, will run "
"without any build process just fine."
msgstr ""

#: ../../doc/doc/developer-manual.rst:939
msgid ""
"Nuitka simply prepares ``<program>.build`` folders with lots of files and"
" tasks scons to execute the final build, after which Nuitka again will "
"take control and do more work as necessary."
msgstr ""

#: ../../doc/doc/developer-manual.rst:945
msgid ""
"When we speak of \"standalone\" mode, this is handled outside of Scons, "
"and after it, creating the \".dist\" folder. This is done in "
"``nuitka.MainControl`` module."
msgstr ""

#: ../../doc/doc/developer-manual.rst:949
msgid ""
"For interfacing to Scons, there is the module "
"``nuitka.build.SconsInterface`` that will support calling ``scons`` - "
"potentially from one of two inline copies (one for before / one for "
"Python 3.5 or later). These are mainly used on Windows or when using "
"source releases - and passing arguments to it. These arguments are passed"
" as ``key=value``, and decoded in the scons file of Nuitka."
msgstr ""

#: ../../doc/doc/developer-manual.rst:956
msgid ""
"The scons file is named ``SingleExe.scons`` for lack of better name. It's"
" really wrong now, but we have yet to find a better name. It once "
"expressed the intention to be used to create executables, but the same "
"works for modules too, as in terms of building, and to Scons, things "
"really are the same."
msgstr ""

#: ../../doc/doc/developer-manual.rst:962
msgid ""
"The scons file supports operation in multiple modes for many things, and "
"modules is just one of them. It runs outside of Nuitka process scope, "
"even with a different Python version potentially, so all the information "
"must be passed on the command line."
msgstr ""

#: ../../doc/doc/developer-manual.rst:967
msgid ""
"What follows is the (lengthy) list of arguments that the scons file "
"processes:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:970
msgid "``source_dir``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:972
msgid ""
"Where is the generated C source code. Scons will just compile everything "
"it finds there. No list of files is passed, but instead this directory is"
" being scanned."
msgstr ""

#: ../../doc/doc/developer-manual.rst:976
msgid "``nuitka_src``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:978
msgid ""
"Where do the include files and static C parts of Nuitka live. These "
"provide e.g. the implementation of compiled function, generators, and "
"other helper codes, this will point to where ``nuitka.build`` package "
"lives normally."
msgstr ""

#: ../../doc/doc/developer-manual.rst:983
msgid "``module_mode``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:985
msgid "Build a module instead of a program."
msgstr ""

#: ../../doc/doc/developer-manual.rst:987
msgid "``result_base``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:989
msgid ""
"This is not a full name, merely the basename for the result to be "
"produced, but with path included, and the suffix comes from module or "
"executable mode."
msgstr ""

#: ../../doc/doc/developer-manual.rst:993
msgid "``debug_mode``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:995
msgid ""
"Enable debug mode, which is a mode, where Nuitka tries to help identify "
"errors in itself, and will generate less optimal code. This also asks for"
" warnings, and makes the build fail if there are any. Scons will pass "
"different compiler options in this case."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1000
msgid "``python_debug``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1002
msgid ""
"Compile and link against Python debug mode, which does assertions and "
"extra checks, to identify errors, mostly related to reference counting. "
"May make the build fail, if no debug build library of CPython is "
"available. On Windows it is possible to install it for CPython3.5 or "
"higher."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1008
msgid "``full_compat_mode``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1010
msgid ""
"Full compatibility, even where it's stupid, i.e. do not provide "
"information, even if available, in order to assert maximum compatibility."
" Intended to control the level of compatibility to absurd."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1015
msgid "``experimental_mode``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1017
msgid "Do things that are not yet accepted to be safe."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1019
msgid "``lto_mode``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1021
msgid ""
"Make use of link time optimization of gcc compiler if available and known"
" good with the compiler in question. So far, this was not found to make "
"major differences."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1025
msgid "``disable_console``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1027
msgid "Windows subsystem mode: Disable console for windows builds."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1029
msgid "``unstripped_mode``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1031
msgid "Unstripped mode: Do not remove debug symbols."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1033
msgid "``clang_mode``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1035
msgid "Clang compiler mode, default on macOS X and FreeBSD, optional on Linux."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1038
msgid "``mingw_mode``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1040
msgid "MinGW compiler mode, optional and useful on Windows only."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1042
msgid "``standalone_mode``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1044
msgid "Building a standalone distribution for the binary."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1046
msgid "``show_scons``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1048
msgid ""
"Show scons mode, output information about Scons operation. This will e.g."
" also output the actual compiler used, output from compilation process, "
"and generally debug information relating to be build process."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1053
msgid "``python_prefix``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1055
msgid ""
"Home of Python to be compiled against, used to locate headers and "
"libraries."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1058
msgid "``target_arch``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1060
msgid "Target architecture to build. Only meaningful on Windows."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1062
msgid "``python_version``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1064
msgid "The major version of Python built against."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1066
msgid "``abiflags``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1068
msgid ""
"The flags needed for the Python ABI chosen. Might be necessary to find "
"the folders for Python installations on some systems."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1071
msgid "``icon_path``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1073
msgid "The icon to use for Windows programs if given."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1076
msgid "Locating Modules and Packages"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1078
msgid ""
"The search for modules used is driven by ``nuitka.importing.Importing`` "
"module."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1081
msgid "Quoting the ``nuitka.importing.Importing`` documentation:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1083
msgid "Locating modules and package source on disk."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1085
msgid ""
"The actual import of a module would already execute code that changes "
"things. Imagine a module that does ``os.system()``, it would be done "
"during compilation. People often connect to databases, and these kind of "
"things, at import time."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1090
msgid ""
"Therefore CPython exhibits the interfaces in an ``imp`` module in "
"standard library, which one can use those to know ahead of time, what "
"file import would load. For us unfortunately there is nothing in CPython "
"that is easily accessible and gives us this functionality for packages "
"and search paths exactly like CPython does, so we implement here a multi "
"step search process that is compatible."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1097
msgid ""
"This approach is much safer of course and there is no loss. To determine "
"if it's from the standard library, one can abuse the attribute "
"``__file__`` of the ``os`` module like it's done in "
"``isStandardLibraryPath`` of this module."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1102
msgid "End quoting the ``nuitka.importing.Importing`` documentation."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1104
msgid "Role"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1106
msgid ""
"This module serves the recursion into modules and analysis if a module is"
" a known one. It will give warnings for modules attempted to be located, "
"but not found. These warnings are controlled by a while list inside the "
"module."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1111
msgid ""
"The decision making and caching are located in the ``nuitka.tree`` "
"package, in modules ``nuitka.tree.Recursion`` and "
"``nuitka.tree.ImportCache``. Each module is only considered once (then "
"cached), and we need to obey lots of user choices, e.g. to compile a "
"standard library or not."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1118
msgid "Hooking for module ``import`` process"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1120
msgid ""
"Currently, in generated code, for every ``import`` a normal "
"``__import__()`` built-in call is executed. The "
"``nuitka/build/static_src/MetaPathBasedLoader.c`` file provides the "
"implementation of a ``sys.meta_path`` hook."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1125
msgid ""
"This meta path based importer allows us to have the Nuitka provided "
"module imported even when imported by non-compiled code."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1130
msgid ""
"Of course, it would make sense to compile time detect which module it is "
"that is being imported and then to make it directly. At this time, we "
"don't have this inter-module optimization yet, mid-term it should become "
"easy to add."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1136
msgid "Supporting ``__class__`` of Python3"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1138
msgid ""
"In Python3 the handling of ``__class__`` and ``super`` is different from "
"Python2. It used to be a normal variable, and now the following things "
"have changed."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1142
msgid ""
"The use of the ``super`` variable name triggers the addition of a closure"
" variable ``__class__``, as can be witnessed by the following code:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1161
msgid "Output is:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1169
msgid "This value of ``__class__`` is also available in the child functions."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1171
msgid ""
"The parser marks up code objects usage of \"super\". It doesn't have to "
"be a call, it can also be a local variable. If the ``super`` built-in is "
"assigned to another name and that is used without arguments, it won't "
"work unless ``__class__`` is taken as a closure variable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1176
msgid ""
"As can be seen in the CPython3 code, the closure value is added after the"
" class creation is performed."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1179
msgid ""
"It appears, that only functions locally defined to the class are affected"
" and take the closure."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1182
msgid "This left Nuitka with the strange problem, of how to emulate that."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1184
msgid "The solution is this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1186
msgid ""
"Under Python3, usage of ``__class__`` as a reference in a child function "
"body is mandatory. It remains that way until all variable names have been"
" resolved."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1192
msgid "When recognizing calls to ``super`` without arguments, make the arguments"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1191
msgid ""
"into variable reference to ``__class__`` and potentially ``self`` "
"(actually first argument name)."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1194
msgid ""
"After all variables have been known, and no suspicious unresolved calls "
"to anything named ``super`` are down, then unused references are "
"optimized away by the normal unused closure variable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1198
msgid "Class dictionary definitions are added."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1200
msgid ""
"These are special direct function calls, ready to propagate also "
"\"bases\" and \"metaclass\" values, which need to be calculated outside."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1203
msgid ""
"The function bodies used for classes will automatically store "
"``__class__`` as a shared local variable, if anything uses it. And if "
"it's not assigned by user code, it doesn't show up in the \"locals()\" "
"used for dictionary creation."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1208
msgid ""
"Existing ``__class__`` local variable values are in fact provided as "
"closure, and overridden with the built class , but they should be used "
"for the closure giving, before the class is finished."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1212
msgid ""
"So ``__class__`` will be local variable of the class body, until the "
"class is built, then it will be the ``__class__`` itself."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1216
msgid "Frame Stack"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1218
msgid ""
"In Python, every function, class, and module has a frame. It creates "
"created when the scope is entered, and there is a stack of these at run "
"time, which becomes visible in tracebacks in case of exceptions."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1222
msgid ""
"The choice of Nuitka is to make this an explicit element of the node "
"tree, that are as such subject to optimization. In cases, where they are "
"not needed, they may be removed."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1226
msgid "Consider the following code."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1236
msgid ""
"In this example, the frame is not needed for all the code, because the "
"condition checked wouldn't possibly raise at all. The idea is the make "
"the frame guard explicit and then to reduce its scope whenever possible."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1240
msgid "So we start out with code like this one:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1251
msgid "This is to be optimized into:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1262
msgid ""
"Notice how the frame guard taking is limited and may be avoided, or in "
"best cases, it might be removed completely. Also this will play a role "
"when in-lining function. The frame stack entry will then be automatically"
" preserved without extra care."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1269
msgid ""
"In the actual code, ``nuitka.nodes.FrameNodes.StatementsFrame`` is "
"represents this as a set of statements to be guarded by a frame presence."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1274
msgid "Parameter Parsing"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1276
msgid ""
"The parsing of parameters is very convoluted in Python, and doing it in a"
" compatible way is not that easy. This is a description of the required "
"process, for an easier overview."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1281
msgid "Input"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1283
msgid ""
"The input is an argument ``tuple`` (the type is fixed), which contains "
"the positional arguments, and potentially an argument ``dict`` (type is "
"fixed as well, but could also be ``NULL``, indicating that there are no "
"keyword arguments."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1289
msgid "Keyword dictionary"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1291
msgid ""
"The keyword argument dictionary is checked first. Anything in there, that"
" cannot be associated, either raise an error, or is added to a "
"potentially given star dict argument. So there are two major cases."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1295
msgid ""
"No star dict argument: Iterate over dictionary, and assign or raise "
"errors."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1298
msgid "This check covers extra arguments given."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1300
msgid ""
"With star dict argument: Iterate over dictionary, and assign or raise "
"errors."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1303
msgid ""
"Interesting case for optimization are no positional arguments, then no "
"check is needed, and the keyword argument dictionary could be used as the"
" star argument. Should it change, a copy is needed though."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1307
msgid ""
"What's noteworthy here, is that in comparison to the keywords, we can "
"hope that they are the same value as we use. The interning of strings "
"increases chances for non-compiled code to do that, esp. for short names."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1312
msgid ""
"We then can do a simple ``is`` comparison and only fall back to real "
"string ``==`` comparisons, after all of these failed. That means more "
"code, but also a lot faster code in the positive case."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1317
msgid "Argument tuple"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1319
msgid ""
"After this completed, the argument tuple is up for processing. The first "
"thing it needs to do is to check if it's too many of them, and then to "
"complain."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1323
msgid ""
"For arguments in Python2, there is the possibility of them being nested, "
"in which case they cannot be provided in the keyword dictionary, and "
"merely should get picked from the argument tuple."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1327
msgid ""
"Otherwise, the length of the argument tuple should be checked against its"
" position and if possible, values should be taken from there. If it's "
"already set (from the keyword dictionary), raise an error instead."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1332
msgid "SSA form for Nuitka"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1334
msgid ""
"The SSA form is critical to how optimization works. The so called trace "
"collections builds up traces. These are facts about how this works:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1337
msgid ""
"Assignments draw from a counter unique for the variable, which becomes "
"the variable version. This happens during tree building phase."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1341
msgid "References are associated with the version of the variable active."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1343
msgid ""
"This can be a merge of branches. Trace collection does do that and "
"provides nodes with the currently active trace for a variable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1346
msgid ""
"The data structures used for trace collection need to be relatively "
"compact as the trace information can become easily much more data than "
"the program itself."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1350
msgid "Every trace collection has these:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1352
msgid "variable_actives"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1354
msgid ""
"Dictionary, where per \"variable\" the currently used version is. Used to"
" track situations changes in branches. This is the main input for merge "
"process."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1358
msgid "variable_traces"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1360
msgid ""
"Dictionary, where \"variable\" and \"version\" form the key. The values "
"are objects with or without an assignment, and a list of usages, which "
"starts out empty."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1364
msgid ""
"These objects have usages appended to them. In \"onVariableSet\", a new "
"version is allocated, which gives a new object for the dictionary, with "
"an empty usages list, because each write starts a new version. In "
"\"onVariableUsage\" the version is detected from the current version. It "
"may be not set yet, which means, it's a read of an undefined value (local"
" variable, not a parameter name), or unknown in case of global variable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1372
msgid ""
"These objects may be told that their value has escaped. This should "
"influence the value friend they attached to the initial assignment. Each "
"usage may have a current value friend state that is different."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1376
msgid ""
"When merging branches of conditional statements, the merge shall apply as"
" follows:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1379
msgid "Branches have their own collection"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1381
msgid ""
"Thee have potentially deviating sets of ``variable_actives``. These are "
"children of an outer collections."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1384
msgid "Case a) One branch only."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1386
msgid ""
"For that branch a collection is performed. As usual new assignments "
"generate a new version making it \"active\", references then related to "
"these \"active\" versions."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1390
msgid ""
"Then, when the branch is merged, for all \"active\" variables, it is "
"considered, if that is a change related to before the branch. If it's not"
" the same, a merge trace with the branch condition is created with the "
"one active in the collection before that statement."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1395
msgid "Case b) Two branches."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1397
msgid ""
"When there are two branches, they both as are treated as above, except "
"for the merge."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1400
msgid ""
"When merging, a difference in active variables between the two branches "
"creates the merge trace."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1405
msgid ""
"For conditional expressions, there are always only two branches. Even if "
"you think you have more than one branch, you do not. It's always nested "
"branches, already when it comes out of the ``ast`` parser."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1409
msgid "Trace structure, there are different kinds of traces."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1411
msgid "Initial write of the version"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1413
msgid ""
"There may be an initial write for each version. It can only occur at the "
"start of the scope, but not later, and there is only one. This might be "
"known to be \"initialized\" (parameter variables of functions are like "
"that) or \"uninitialized\", or \"unknown\"."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1418
msgid "Merge of other one or two other versions"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1420
msgid ""
"This combines two or more previous versions. In cases of loop exits or "
"entries, there are multiple branches to combine potentially. These "
"branches can have vastly different properties."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1424
msgid "Becoming unknown."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1426
msgid ""
"When control flow escapes, e.g. for a module variable, any write can "
"occur to it, and it's value cannot be trusted to be unchanged. These are "
"then traced as unknown."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1430
msgid ""
"All traces have a base class ``ValueTraceBase`` which provides the "
"interface to query facts about the state of a variable in that trace. "
"It's e.g. of some interest, if a variable must have a value or must not. "
"This allows to e.g. omit checks, know what exceptions might raise."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1436
msgid "Loop SSA"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1438
msgid ""
"For loops we have the addition difficulty that we need would need to look"
" ahead what types a variable has at loop exit, but that is a cyclic "
"dependency."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1442
msgid ""
"Our solution is to consider the variable types at loop entry. When these "
"change, we drop all gained information from inside the loop. We may e.g. "
"think that a variable is a ``int`` or ``float``, but later recognize that"
" it can only be a float. Derivations from ``int`` must be discarded, and "
"the loop analysis restarted."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1448
msgid ""
"Then during the loop, we assign an incomplete loop trace shape to the "
"variable, which e.g. says it was an ``int`` initially and additional type"
" shapes, e.g. ``int or long`` are then derived. If at the end of the "
"loop, a type produced no new types, we know we are finished and mark the "
"trace as a complete loop trace."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1454
msgid ""
"If it is not, and next time, we have the same initial types, we add the "
"ones derived from this to the starting values, and see if this gives more"
" types."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1459
msgid "Python Slots in Optimization"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1462
msgid "Basic Slot Idea"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1464
msgid ""
"For almost all the operations in Python, a form of overloading is "
"available. That is what makes it so powerful."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1467
msgid "So when you write an expression like this one:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1473
msgid ""
"This something will not just blindly work when it's a float, but go "
"through a slot mechanism, which then can be overloaded."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1487
msgid ""
"Here it is the case, that this is used by user code, but more often this "
"is used internally. Not all types have all slots, e.g. ``list`` does not "
"have ``__float__`` and therefore will refuse an addition to a ``float`` "
"value, based on that."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1492
msgid ""
"Another slot is working here, that we didn't mention yet, and that is "
"``__add__`` which for some times will be these kinds of conversions or it"
" will not do that kind of thing, e.g. something do hard checks, which is "
"why this fails to work:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1501
msgid ""
"As a deliberate choice, there is no ``__list__`` slot used. The Python "
"designers are aiming at solving many things with slots, but they also "
"accept limitations."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1505
msgid ""
"There are many slots that are frequently used, most often behind your "
"back (``__iter__``, ``__next__``, ``__lt__``, etc.). The list is large, "
"and tends to grow with Python releases, but it is not endless."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1510
msgid "Representation in Nuitka"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1512
msgid ""
"So a slot in Nuitka typically has an owning node. We use ``__len__`` as "
"an example here. In the ``computeExpression`` the ``len`` node named "
"``ExpressionBuiltinLen`` has to defer the decision what it computes to "
"its argument."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1524
msgid ""
"That decision then, in the absence of any type knowledge, must be done "
"absolutely carefully and conservative, as could see anything executing "
"here."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1528
msgid ""
"That examples this code in ``ExpressionBase`` which every expression by "
"default uses:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1574
msgid ""
"Notice how by default, known ``__len__`` but unpredictable or even "
"unknown if a ``__len__`` slot is there, the code indicates that its "
"contents and the control flow escapes (could change things behind out "
"back) and any exception could happen."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1579
msgid ""
"Other expressions can know better, e.g. for compile time constants we can"
" be a whole lot more certain:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1591
msgid ""
"In this case, we are using a function that will produce a concrete value "
"or the exception that the ``computation`` function raised. In this case, "
"we can let the Python interpreter that runs Nuitka do all the hard work. "
"This lives in ``CompileTimeConstantExpressionBase`` and is the base for "
"all kinds of constant values, or even built-in references like the name "
"``len`` itself and would be used in case of doing ``len(len)`` which "
"obviously gives an exception."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1599
msgid ""
"Other overloads do not currently exist in Nuitka, but through the "
"iteration length, most cases could be addressed, e.g. ``list`` nodes "
"typical know their element counts."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1604
msgid "The C side"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1606
msgid ""
"When a slot is not optimized away at compile time however, we need to "
"generate actual code for it. We figure out what this could be by looking "
"at the original CPython implementation."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1621
msgid ""
"We find a pointer to ``PyObject_Size`` which is a generic Python C/API "
"function used in the ``builtin_len`` implementation:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1641
msgid ""
"On the C level, every Python object (the ``PyObject *``) as a type named "
"``ob_type`` and most of its elements are slots. Sometimes they form a "
"group, here ``tp_as_sequence`` and then it may or may not contain a "
"function. This one is tried in preference. Then, if that fails, next up "
"the mapping size is tried."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1665
msgid ""
"This is the same principle, except with ``tp_as_mapping`` and "
"``mp_length`` used."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1668
msgid ""
"So from this, we can tell how ``len`` gets at what could be a Python "
"class ``__len__`` or other built-in types."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1671
msgid ""
"In principle, every slot needs to be dealt with in Nuitka, and it is "
"assumed that currently all slots are supported on at least a very "
"defensive level, to avoid unnoticed escapes of control flow."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1676
msgid "Built-in call optimization"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1678
msgid ""
"For calls to built-in names, there is typically a function in Python that"
" delegates to the type constructor (e.g. when we talk about ``int`` that "
"just creates an object passing the arguments of the call) or its own "
"special implementation as we saw with the ``len``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1683
msgid ""
"For each built-in called, we have a specialized node, that presents to "
"optimization the actions of the built-in. What are the impact, what are "
"the results. We have seen the resulting example for ``len`` above, but "
"how do we get there."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1688
msgid ""
"In Python, built-in names are used only if there is no module level "
"variable of the name, and of course no local variable of that name."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1691
msgid ""
"Therefore, optimization of a built-in name is only done if it turns out "
"the actually assigned in other code, and then when the call comes, "
"arguments are checked and a relatively static node is created."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1696
msgid "Code Generation towards C"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1698
msgid ""
"Currently, Nuitka uses Pure C and no C++ patterns at all. The use of C11 "
"requires on some platforms to compile the C11 using a C++ compiler, which"
" works relatively well, but also limits the amount of C11 that can be "
"used."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1704
msgid "Exceptions"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1706
msgid ""
"To handle and work with exceptions, every construct that can raise has "
"either a ``bool`` or ``int`` return code or ``PyObject *`` with ``NULL`` "
"return value. This is very much in line with that the Python C-API does."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1710
msgid ""
"Every helper function that contains code that might raise needs these "
"variables. After a failed call, our variant of ``PyErr_Fetch`` called "
"``FETCH_ERROR_OCCURRED`` must be used to catch the defined error, unless "
"some quick exception cases apply. The quick exception means, ``NULL`` "
"return from C-API without a set exception means e.g. ``StopIteration``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1716
msgid ""
"As an optimization, functions that raise exceptions, but are known not to"
" do so, for whatever reason, could only be asserted to not do so."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1720
msgid "Statement Temporary Variables"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1722
msgid ""
"For statements and larger constructs the context object track temporary "
"values, that represent references. For some, these should be released at "
"the end of the statement, or they represent a leak."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1726
msgid ""
"The larger scope temporary variables, are tracked in the function or "
"module context, where they are supposed to have explicit ``del`` to "
"release their references."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1731
msgid "Local Variables Storage"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1733
msgid ""
"Closure variables taken are to be released when the function object is "
"later destroyed. For in-lined calls, variables are just passed, and it "
"does not become an issue to release anything."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1737
msgid ""
"For function exit, owned variables, local or shared to other functions, "
"must be released. This cannot be a ``del`` operation, as it also involves"
" setting a value, which would be wrong for shared variables (and wasteful"
" to local variables, as that would be its last usage). Therefore we need "
"a special operation that simply releases the reference to the cell or "
"object variable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1745
msgid "Exit Targets"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1747
msgid ""
"Each error or other exit releases statement temporary values and then "
"executes a ``goto`` to the exit target. These targets need to be setup. "
"The ``try``/``except`` will e.g. catch error exits."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1751
msgid ""
"Other exits are ``continue``, ``break``, and ``return`` exits. They all "
"work alike."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1754
msgid ""
"Generally, the exits stack of with constructs that need to register "
"themselves for some exit types. A loop e.g. registers the ``continue`` "
"exit, and a contained ``try``/``finally`` too, so it can execute the "
"final code should it be needed."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1760
msgid "Frames"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1762
msgid ""
"Frames are containers for variable declarations and cleanups. As such, "
"frames provide error exits and success exits, which remove the frame from"
" the frame stack, and then proceed to the parent exit."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1766
msgid ""
"With the use of non ``PyObject **`` C types, but frame exception exits, "
"the need to convert those types becomes apparent. Exceptions should still"
" resolve the C version. When using different C types at frame exception "
"exits, there is a need to trace the active type, so it can be used in the"
" correct form."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1773
msgid "Abortive Statements"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1775
msgid ""
"The way ``try``/``finally`` is handled, copies of the ``finally`` block "
"are made, and optimized independently for each abort method. The ones "
"there are of course, ``return``, ``continue``, and ``break``, but also "
"implicit and explicit ``raise`` of an exception."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1780
msgid ""
"Code trailing an abortive statement can be discarded, and the control "
"flow will follow these \"exits\"."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1784
msgid "Constant Preparation"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1786
msgid ""
"Early versions of Nuitka, created all constants for the whole program for"
" ready access to generated code, before the program launches. It did so "
"in a single file, but that approach didn't scale well."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1790
msgid "Problems were"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1792
msgid ""
"Even unused code contributed to start-up time, this can become a lot for "
"large programs, especially in standalone mode."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1795
msgid ""
"The massive amount of constant creation codes gave backend C compilers a "
"much harder time than necessary to analyse it all at once."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1799
msgid ""
"The current approach is as follows. Code generation detects constants "
"used in only one module, and declared ``static`` there, if the module is "
"the only user, or ``extern`` if it is not. Some values are forced to be "
"global, as they are used pre-main or in helpers."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1804
msgid ""
"These ``extern`` values are globally created before anything is used. The"
" ``static`` values are created when the module is loaded, i.e. something "
"did import it."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1808
msgid ""
"We trace used constants per module, and for nested ones, we also "
"associate them. The global constants code is special in that it can only "
"use ``static`` for nested values it exclusively uses, and has to export "
"values that others use."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1814
msgid "Language Conversions to make things simpler"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1816
msgid ""
"There are some cases, where the Python language has things that can in "
"fact be expressed in a simpler or more general way, and where we choose "
"to do that at either tree building or optimization time."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1821
msgid "The ``assert`` statement"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1823
msgid ""
"The ``assert`` statement is a special statement in Python, allowed by the"
" syntax. It has two forms, with and without a second argument. The later "
"is probably less known, as is the fact that raise statements can have "
"multiple arguments too."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1828
msgid "The handling in Nuitka is:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1844
msgid ""
"This makes assertions absolutely the same as a raise exception in a "
"conditional statement."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1847
msgid ""
"This transformation is performed at tree building already, so Nuitka "
"never knows about ``assert`` as an element and standard optimizations "
"apply. If e.g. the truth value of the assertion can be predicted, the "
"conditional statement will have the branch statically executed or "
"removed."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1854
msgid "The \"comparison chain\" expressions"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1856
msgid ""
"In Nuitka we have the concept of an outline, and therefore we can make "
"the following re-formulation instead:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1888
msgid ""
"This transformation is performed at tree building already. The temporary "
"variables keep the value for the use of the same expression. Only the "
"last expression needs no temporary variable to keep it."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1892
msgid ""
"What we got from this, is making the checks of the comparison chain "
"explicit and comparisons in Nuitka to be internally always about two "
"operands only."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1897
msgid "The ``execfile`` built-in"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1899
msgid "Handling is:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1909
msgid ""
"This allows optimizations to discover the file opening nature easily and "
"apply file embedding or whatever we will have there one day."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1912
msgid ""
"This transformation is performed when the ``execfile`` built-in is "
"detected as such during optimization."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1916
msgid "Generator expressions with ``yield``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1918
msgid ""
"These are converted at tree building time into a generator function body "
"that yields from the iterator given, which is the put into a for loop to "
"iterate, created a lambda function of and then called with the first "
"iterator."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1923
msgid ""
"That eliminates the generator expression for this case. It's a bizarre "
"construct and with this trick needs no special code generation."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1926
msgid ""
"This is a complex example, demonstrating multiple cases of yield in "
"unexpected cases:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1939
msgid "Function Decorators"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1941
msgid "When one learns about decorators, you see that:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1957
msgid ""
"The only difference is the assignment to function. In the ``@decorator`` "
"case, if the decorator fails with an exception, the name ``function`` is "
"not assigned yet, but kept in a temporary variable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1961
msgid ""
"Therefore in Nuitka this assignment is more similar to that of a lambda "
"expression, where the assignment to the name is only at the end, which "
"also has the extra benefit of not treating real function and lambda "
"functions any different."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1966
msgid ""
"This removes the need for optimization and code generation to support "
"decorators at all. And it should make the two variants optimize equally "
"well."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1971
msgid "Functions nested arguments"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1973
msgid ""
"Nested arguments are a Python2 only feature supported by Nuitka. Consider"
" this example:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1981
msgid ""
"We solve this, by kind of wrapping the function with another function "
"that does the unpacking and gives the errors that come from this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:1993
msgid ""
"The ``.1`` is the variable name used by CPython internally, and actually "
"works if you use keyword arguments via star dictionary. So this is very "
"compatible and actually the right kind of re-formulation, but it removes "
"the need from the code that does parameter parsing to deal with these."
msgstr ""

#: ../../doc/doc/developer-manual.rst:1998
msgid ""
"Obviously, there is no frame for ``_tmp``, just one for ``function`` and "
"we do not use local variables, but temporary functions."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2002
msgid "In-place Assignments"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2004
msgid ""
"In-place assignments are re-formulated to an expression using temporary "
"variables."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2007
msgid ""
"These are not as much a reformulation of ``+=`` to ``+``, but instead one"
" which makes it explicit that the assign target may change its value."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2021
msgid ""
"Using ``__iadd__`` here to express that for the ``+``, the in-place "
"variant ``iadd`` is used instead. The ``is`` check may be optimized away "
"depending on type and value knowledge later on."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2026
msgid "Complex Assignments"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2028
msgid ""
"Complex assignments are defined as those with multiple targets to assign "
"from a single source and are re-formulated to such using a temporary "
"variable and multiple simple assignments instead."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2043
msgid ""
"This is possible, because in Python, if one assignment fails, it can just"
" be interrupted, so in fact, they are sequential, and all that is "
"required is to not calculate ``c`` twice, which the temporary variable "
"takes care of. Were ``b`` a more complex expression, e.g. "
"``b.some_attribute`` that might raise an exception, ``a`` would still be "
"assigned."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2051
msgid "Unpacking Assignments"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2053
msgid ""
"Unpacking assignments are re-formulated to use temporary variables as "
"well."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2060
msgid "Becomes this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2084
msgid ""
"That way, the unpacking is decomposed into multiple simple statements. It"
" will be the job of optimizations to try and remove unnecessary "
"unpacking, in case e.g. the source is a known tuple or list creation."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2090
msgid ""
"The ``unpack`` is a special node which is a form of ``next`` that will "
"raise a ``ValueError`` when it cannot get the next value, rather than a "
"``StopIteration``. The message text contains the number of values to "
"unpack, therefore the integer argument."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2097
msgid ""
"The ``unpack_check`` is a special node that raises a ``ValueError`` "
"exception if the iterator is not finished, i.e. there are more values to "
"unpack. Again the number of values to unpack is provided to construct the"
" error message."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2103
msgid "With Statements"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2105
msgid ""
"The ``with`` statements are re-formulated to use temporary variables as "
"well. The taking and calling of ``__enter__`` and ``__exit__`` with "
"arguments, is presented with standard operations instead. The promise to "
"call ``__exit__`` is fulfilled by ``try``/``except`` clause instead."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2156
msgid ""
"We don't refer really to ``sys.exc_info()`` at all, instead, we have fast"
" references to the current exception type, value and trace, taken "
"directly from the caught exception object on the C level."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2160
msgid ""
"If we had the ability to optimize ``sys.exc_info()`` to do that, we could"
" use the same transformation, but right now we don't have it."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2164
msgid "For Loops"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2166
msgid ""
"The ``for`` loops use normal assignments and handle the iterator that is "
"implicit in the code explicitly."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2177
msgid "This is roughly equivalent to the following code:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2207
msgid ""
"The ``_iter`` temporary variable is of course also in a ``try/finally`` "
"construct, to make sure it releases after its used. The ``x, y`` "
"assignment is of course subject to unpacking re-formulation."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2212
msgid ""
"The ``try``/``except`` is detected to allow to use a variant of ``next`` "
"that does not raise an exception, but to be fast check about the ``NULL``"
" return from ``next`` built-in. So no actual exception handling is "
"happening in this case."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2218
msgid "While Loops"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2220
msgid ""
"Quoting the ``nuitka.tree.ReformulationWhileLoopStatements`` "
"documentation:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2223
msgid "Reformulation of while loop statements."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2225
msgid ""
"Loops in Nuitka have no condition attached anymore, so while loops are "
"re-formulated like this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2241
msgid ""
"This is to totally remove the specialization of loops, with the condition"
" moved to the loop body in an initial conditional statement, which "
"contains a ``break`` statement."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2245
msgid ""
"That achieves, that only ``break`` statements exit the loop, and allow "
"for optimization to remove always true loop conditions, without "
"concerning code generation about it, and to detect such a situation, "
"consider e.g. endless loops."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2252
msgid ""
"Loop analysis (not yet done) can then work on a reduced problem (which "
"``break`` statements are executed under what conditions) and is then "
"automatically very general."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2256
msgid ""
"The fact that the loop body may not be entered at all, is still "
"optimized, but also in the general sense. Explicit breaks at the loop "
"start and loop conditions are the same."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2260
msgid ""
"End quoting the ``nuitka.tree.ReformulationWhileLoopStatements`` "
"documentation:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2264
msgid "Exception Handlers"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2266
msgid ""
"Exception handlers in Python may assign the caught exception value to a "
"variable in the handler definition. And the different handlers are "
"represented as conditional checks on the result of comparison operations."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2302
msgid ""
"For Python3, the assigned ``e`` variables get deleted at the end of the "
"handler block. Should that value be already deleted, that ``del`` does "
"not raise, therefore it's tolerant. This has to be done in any case, so "
"for Python3 it is even more complex."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2333
msgid ""
"Should there be no ``else:`` branch, a default re-raise statement is used"
" instead."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2336
msgid ""
"And of course, the values of the current exception type and value, both "
"use special references, that access the C++ and don't go via "
"``sys.exc_info`` at all, nodes called ``CaughtExceptionTypeRef`` and "
"``CaughtExceptionValueRef``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2341
msgid ""
"This means, that the different handlers and their catching run time "
"behavior are all explicit and reduced the branches."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2345
msgid "Statement ``try``/``except`` with ``else``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2347
msgid ""
"Much like ``else`` branches of loops, an indicator variable is used to "
"indicate the entry into any of the exception handlers."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2350
msgid ""
"Therefore, the ``else`` becomes a real conditional statement in the node "
"tree, checking the indicator variable and guarding the execution of the "
"``else`` branch."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2355
msgid "Class Creation (Python2)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2357
msgid ""
"Classes in Python2 have a body that only serves to build the class "
"dictionary and is a normal function otherwise. This is expressed with the"
" following re-formulation:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2393
msgid ""
"That is roughly the same, except that ``_makeSomeClass`` is *not* visible"
" to its child functions when it comes to closure taking, which we cannot "
"express in Python language at all."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2397
msgid ""
"Therefore, class bodies are just special function bodies that create a "
"dictionary for use in class creation. They don't really appear after the "
"tree building stage anymore. The type inference will of course have to "
"become able to understand ``make_class`` quite well, so it can recognize "
"the created class again."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2404
msgid "Class Creation (Python3)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2406
msgid ""
"In Python3, classes are a complicated way to write a function call, that "
"can interact with its body. The body starts with a dictionary provided by"
" the metaclass, so that is different, because it can ``__prepare__`` a "
"non-empty locals for it, which is hidden away in \"prepare_class_dict\" "
"below."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2412
msgid ""
"What's noteworthy, is that this dictionary, could e.g. be an "
"``OrderDict``. I am not sure, what ``__prepare__`` is allowed to return."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2463
msgid "Generator Expressions"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2465
msgid "There are re-formulated as functions."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2467
msgid ""
"Generally they are turned into calls of function bodies with (potentially"
" nested) for loops:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2485
msgid "List Contractions"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2487
msgid ""
"The list contractions of Python2 are different from those of Python3, in "
"that they don't actually do any closure variable taking, and that no "
"function object ever exists."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2509
msgid ""
"The difference is that with Python3, the function \"_listcontr_helper\" "
"is really there and named ``<listcontraction>`` (or ``<listcomp>`` as of "
"Python3.7 or higher), whereas with Python2 the function is only an "
"outline, so it can readily access the containing name space."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2515
msgid "Set Contractions"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2517
msgid ""
"The set contractions of Python2.7 are like list contractions in Python3, "
"in that they produce an actual helper function:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2539
msgid "Dictionary Contractions"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2541
msgid ""
"The dictionary contractions of are like list contractions in Python3, in "
"that they produce an actual helper function:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2563
msgid "Boolean expressions ``and`` and ``or``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2565
msgid ""
"The short circuit operators ``or`` and ``and`` tend to be only less "
"general that the ``if``/``else`` expressions, but have dedicated nodes. "
"We used to have a re-formulation towards those, but we now do these via "
"dedicated nodes too."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2570
msgid ""
"These new nodes, present the evaluation of the left value, checking for "
"its truth value, and depending on it, to pick it, or use the right value."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2575
msgid "Simple Calls"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2577
msgid ""
"As seen below, even complex calls are simple calls. In simple calls of "
"Python there is still some hidden semantic going on, that we expose."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2584
msgid ""
"On the C-API level there is a tuple and dictionary built. This one is "
"exposed:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2591
msgid ""
"A called function will access this tuple and the dictionary to parse the "
"arguments, once that is also re-formulated (argument parsing), it can "
"then lead to simple in-lining. This way calls only have 2 arguments with "
"constant semantics, that fits perfectly with the C-API where it is the "
"same, so it is actually easier for code generation."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2597
msgid ""
"Although the above looks like a complex call, it actually is not. No "
"checks are needed for the types of the star arguments and it's directly "
"translated to ``PyObject_Call``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2602
msgid "Complex Calls"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2604
msgid "The call operator in Python allows to provide arguments in 4 forms."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2606
msgid "Positional (or normal) arguments"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2608
msgid "Named (or keyword) arguments"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2610
msgid "Star list arguments"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2612
msgid "Star dictionary arguments"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2614
msgid "The evaluation order is precisely that. An example would be:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2620
msgid ""
"The task here is that first all the arguments are evaluated, left to "
"right, and then they are merged into only two, that is positional and "
"named arguments only. for this, the star list argument and the star "
"dictionary arguments, are merged with the positional and named arguments."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2626
msgid ""
"What's peculiar, is that if both the star list and dictionary arguments "
"are present, the merging is first done for star dictionary, and only "
"after that for the star list argument. This makes a difference, because "
"in case of an error, the star argument raises first."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2635
msgid ""
"This raises \"TypeError: something() argument after ** must be a mapping,"
" not int\" as opposed to a possibly more expected \"TypeError: "
"something() argument after * must be a sequence, not int.\""
msgstr ""

#: ../../doc/doc/developer-manual.rst:2639
msgid ""
"That doesn't matter much though, because the value is to be evaluated "
"first anyway, and the check is only performed afterwards. If the star "
"list argument calculation gives an error, this one is raised before "
"checking the star dictionary argument."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2644
msgid ""
"So, what we do, is we convert complex calls by the way of special "
"functions, which handle the dirty work for us. The optimization is then "
"tasked to do the difficult stuff. Our example becomes this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2672
msgid ""
"The call to ``_complex_call`` is be a direct function call with no "
"parameter parsing overhead. And the call in its end, is a special call "
"operation, which relates to the ``PyObject_Call`` C-API."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2677
msgid "Match Statements"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2689
msgid "This is the same as"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2717
msgid "Print Statements"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2719
msgid ""
"The ``print`` statement exists only in Python2. It implicitly converts "
"its arguments to strings before printing them. In order to make this "
"accessible and compile time optimized, this is made visible in the node "
"tree."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2728
msgid ""
"This is in Nuitka converted so that the code generation for ``print`` "
"doesn't do any conversions itself anymore and relies on the string nature"
" of its input."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2736
msgid ""
"Only string objects are spared from the ``str`` built-in wrapper, because"
" that would only cause noise in optimization stage. Later optimization "
"can then find it unnecessary for certain arguments."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2740
msgid ""
"Additionally, each ``print`` may have a target, and multiple arguments, "
"which we break down as well for dumber code generation. The target is "
"evaluated first and should be a file, kept referenced throughout the "
"whole print statement."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2749
msgid "This is being reformulated to:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2762
msgid ""
"This allows code generation to not deal with arbitrary amount of "
"arguments to ``print``. It also separates the newline indicator from the "
"rest of things, which makes sense too, having it as a special node, as "
"it's behavior with regards to soft-space is different of course."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2767
msgid ""
"And finally, for ``print`` without a target, we still assume that a "
"target was given, which would be ``sys.stdout`` in a rather hard-coded "
"way (no variable look-ups involved)."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2772
msgid "Reformulations during Optimization"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2775
msgid "Builtin ``zip`` for Python2"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2822
msgid "Builtin ``zip`` for Python3"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2852
msgid "Builtin ``map`` for Python2"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2861
msgid "Builtin ``min``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2894
msgid "Builtin ``max``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2896
msgid "See ``min`` just with ``>`` instead of ``<``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2899
msgid "Call to ``dir`` without arguments"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2901
msgid ""
"This expression is reformulated to ``locals().keys()`` for Python2, and "
"``list(locals.keys())`` for Python3."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2905
msgid "Calls to functions with known signatures"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2907
msgid ""
"As a necessary step for inlining function calls, we need to change calls "
"to variable references to function references."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2920
msgid "In the optimization it is turned into"
msgstr ""

#: ../../doc/doc/developer-manual.rst:2930
msgid ""
"The ``lambda`` stands here for a reference to the function, rather than a"
" variable reference, this is the normal forward propagation of values, "
"and does not imply duplicating or moving any code at all."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2934
msgid ""
"At this point, we still have not resolved the actual call arguments to "
"the variable names, still a Python level function is created, and called,"
" and arguments are parsed to a tuple, and from a tuple. For simplicity "
"sake, we have left out keyword arguments out of the equation for now, but"
" they are even more costly."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2940
msgid ""
"So now, what we want to do, is to re-formulate the call into what we call"
" an outline body, which is a inline function, and that does the parameter"
" parsing already and contains the function code too. In this inlining, "
"there still is a function, but it's technically not a Python function "
"anymore, just something that is an expression whose value is determined "
"by control flow and the function call."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2960
msgid ""
"With this, a function is considered inlined, because it becomes part of "
"the abstract execution, and the actual code is duplicated."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2963
msgid ""
"The point is, that matching the signature of the function to the actual "
"arguments given, is pretty straight forward in many cases, but there are "
"two forms of complications that can happen. One is default values, "
"because they need to assigned or not, and the other is keyword arguments,"
" because they allow to reorder arguments."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2969
msgid "Lets consider an example with default values first."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2981
msgid ""
"Since the point, at which defaults are taken, we must execute them at "
"that point and make them available."
msgstr ""

#: ../../doc/doc/developer-manual.rst:2999
msgid "Now, one where keyword arguments are ordered the other way."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3011
msgid ""
"The solution is an extra level of temporary variables. We remember the "
"argument order by names and then assign parameters from it:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3029
msgid ""
"Obviously, optimization of Nuitka can decide, that e.g. should ``a`` or "
"``b+c`` not have side effects, to optimize these with standard variable "
"tracing away."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3034
msgid "Nodes that serve special purposes"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3037
msgid "Try statements"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3039
msgid ""
"In Python, there is ``try``/``except`` and ``try``/``finally``. In Nuitka"
" there is only a ``try``, which then has blocks to handle exceptions, "
"``continue``, or ``break``, or ``return``. There is no ``else`` to this "
"node type."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3044
msgid ""
"This is more low level and universal. Code for the different handlers can"
" be different. User provided ``finally`` blocks become copied into the "
"different handlers."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3049
msgid "Releases"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3051
msgid ""
"When a function exits, the local variables are to be released. The same "
"applies to temporary variables used in re-formulations. These releases "
"cause a reference to the object to the released, but no value change. "
"They are typically the last use of the object in the function."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3056
msgid ""
"The are similar to ``del``, but make no value change. For shared "
"variables this effect is most visible."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3060
msgid "Side Effects"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3062
msgid ""
"When an exception is bound to occur, and this can be determined at "
"compile time, Nuitka will not generate the code the leads to the "
"exception, but directly just raise it. But not in all cases, this is the "
"full thing."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3067
msgid "Consider this code:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3073
msgid ""
"The second argument will create a ``ZeroDivisionError`` exception, but "
"before that ``a()`` must be executed, but the call to ``f`` will never "
"happen and no code is needed for that, but the name look-up must still "
"succeed. This then leads to code that is internally like this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3082
msgid "which is then modeled as:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3088
msgid ""
"where we can consider ``side_effect`` to be a function that returns the "
"last expression. Of course, if this is not part of another expression, "
"but close to statement level, side effects, can be converted to multiple "
"statements simply."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3093
msgid ""
"Another use case, is that the value of an expression can be predicted, "
"but that the language still requires things to happen, consider this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3100
msgid ""
"We can tell that ``a`` will be 2, but the call to ``f`` and ``g`` must "
"still be performed, so it becomes:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3107
msgid ""
"Modelling side effects explicitly has the advantage of recognizing them "
"easily and allowing to drop the call to the tuple building and checking "
"its length, only to release it."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3112
msgid "Caught Exception Type/Value References"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3114
msgid ""
"When catching an exception, these are not directly put to "
"``sys.exc_info()``, but remain as mere C variables. From there, they can "
"be accessed with these nodes, or if published then from the thread state."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3120
msgid "Hard Module Imports"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3122
msgid ""
"These are module look-ups that don't depend on any local variable for the"
" module to be looked up, but with hard-coded names. These may be the "
"result of optimization gaining such level of certainty."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3126
msgid ""
"Currently they are used to represent ``sys.stdout`` usage for ``print`` "
"statements, but other usages will follow."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3130
msgid "Locals Dict Update Statement"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3132
msgid ""
"For the ``exec`` re-formulation, we apply an explicit sync back to locals"
" as an explicit node. It helps us to tell the affected local variable "
"traces that they might be affected. It represents the bit of ``exec`` in "
"Python2, that treats ``None`` as the locals argument as an indication to "
"copy back."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3139
msgid "Optimizing Attribute Lookups into Method Calls for Built-ins types"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3141
msgid ""
"The attribute lookup node ``ExpressionAttributeLookup`` represents "
"looking up an attribute name, that is known to be a string. That's "
"already a bit more special, than say what ``ExpressionBuiltinGetattr`` "
"does for ``getattr``, where it could be any object being looked up. From "
"the Python syntax however, these are what gets created, as it's not "
"allowed in any other way. So, this is where this starts."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3148
msgid ""
"Then, when we are creating an attribute node with a *fixed* name, we "
"dispatch it to generated node classes, e.g. "
"``ExpressionAttributeLookupFixedAppend``. This will be the same, except "
"that the attribute name is hardcoded."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3153
msgid ""
"There are generated, such that they can have code that is special for "
"``.append`` lookups. In their case, it makes sense to ask the source, if "
"they are a ``list`` object exactly. It doesn't make sense to do this "
"check for names that the ``list`` does not contain. So at that stage, we "
"are saving both a bit of memory and time."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3159
msgid ""
"Should this question succeed, i.e. the expression the attribute values is"
" looked up upon, is known to be a ``list`` exactly, we persist this "
"knowledge in the also generated nodes that represent ``list.append`` and "
"just that. It is called ``ExpressionAttributeLookupListAppend`` and only "
"represents the knowledge gained so far."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3165
msgid ""
"We do not consider if ``ExpressionAttributeLookupFixedAppend`` is called,"
" or not, passed as an argument, assigned somewhere, it doesn't matter "
"yet, but for ``ExpressionAttributeLookupListAppend`` we know a hell of a "
"lot more. We know its type, we know attributes for it, say ``__name__``, "
"as it is a compile time constant, therefore much optimization can follow "
"for them, and code generation can specialize them too (not yet done)."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3173
msgid ""
"Should these nodes then, and say this happens later after some inlining "
"happens be seen as called, we can then turn them into method call nodes, "
"checking the arguments and such, this is then "
"``ExpressionListOperationAppend`` and at this point, will raising errors "
"with wrong argument counts."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3179
msgid ""
"And then we have this ``ExpressionListOperationAppend`` which will "
"influence the tracing of ``list`` contents, i.e. it will be able to tell "
"the ``list`` in question is no more empty after this ``append``, and it "
"will be able to at least predict the last element value, truth value of "
"the list, etc."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3187
msgid "Plan to add \"ctypes\" support"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3189
msgid ""
"Add interfacing to C code, so Nuitka can turn a ``ctypes`` binding into "
"an efficient binding as if it were written manually with Python C-API or "
"better."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3194
msgid "Goals/Allowances to the task"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3196
msgid ""
"Goal: Must not directly use any pre-existing C/C++ language file headers,"
" only generate declarations in generated C code ourselves. We would "
"rather write or use tools that turn an existing a C header to some "
"``ctypes`` declarations if it needs to be, but not mix and use "
"declarations from existing header code."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3204
msgid ""
"The \"cffi\" interface maybe won't have the issue, but it's not something"
" we need to write or test the code for."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3207
msgid ""
"Allowance: May use ``ctypes`` module at compile time to ask things about "
"``ctypes`` and its types."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3210
msgid ""
"Goal: Should make use of ``ctypes``, to e.g. not hard code in Nuitka what"
" ``ctypes.c_int()`` gives on the current platform, unless there is a "
"specific benefit."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3214
msgid "Allowance: Not all ``ctypes`` usages must be supported immediately."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3216
msgid "Goal: Try and be as general as possible."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3218
msgid ""
"For the compiler, ``ctypes`` support should be hidden behind a generic "
"interface of some sort. Supporting ``math`` module should be the same "
"thing."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3223
msgid "Type Inference - The Discussion"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3225
msgid ""
"Main initial goal is to forward value knowledge. When you have ``a = b``,"
" that means that a and b now \"alias\". And if you know the value of "
"``b`` you can assume to know the value of ``a``. This is called "
"\"aliasing\"."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3230
msgid ""
"When assigning ``a`` to something new, that won't change ``b`` at all. "
"But when an attribute is set, a method called of it, that might impact "
"the actual value, referenced by both. We need to understand mutable vs. "
"immutable though, as some things are not affected by aliasing in any way."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3248
msgid ""
"If we cannot tell, we must assume that ``a`` might be changed. It's "
"either ``b`` or what ``a`` was before. If the type is not mutable, we can"
" assume the aliasing to be broken up, and if it is, we can assume both to"
" be the same value still."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3253
msgid ""
"When that value is a compile time constant, we will want to push it "
"forward, and we do that with \"(Constant) Value Propagation\", which is "
"implemented already. We avoid too large constants, and we properly trace "
"value assignments, but not yet aliases."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3258
msgid ""
"In order to fully benefit from type knowledge, the new type system must "
"be able to be fully friends with existing built-in types, but for classes"
" to also work with it, it should not be tied to them. The behavior of a "
"type ``long``, ``str``, etc. ought to be implemented as far as possible "
"with the built-in ``long``, ``str`` at compiled time as well."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3267
msgid ""
"This \"use the real thing\" concept extends beyond builtin types, e.g. "
"``ctypes.c_int()`` should also be used, but we must be aware of platform "
"dependencies. The maximum size of ``ctypes.c_int`` values would be an "
"example of that. Of course that may not be possible for everything."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3273
msgid ""
"This approach has well proven itself with built-in functions already, "
"where we use real built-ins where possible to make computations. We have "
"the problem though that built-ins may have problems to execute everything"
" with reasonable compile time cost."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3278
msgid "Another example, consider the following code:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3284
msgid ""
"To predict this code, calculating it at compile time using constant "
"operations, while feasible, puts an unacceptable burden on the "
"compilation."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3288
msgid ""
"Esp. we wouldn't want to produce such a huge constant and stream it, the "
"C++ code would become too huge. So, we need to stop the ``*`` operator "
"from being used at compile time and cope with reduced knowledge, already "
"here:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3297
msgid "Instead, we would probably say that for this expression:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3299
msgid "The result is a ``str`` or a C level ``PyStringObject *``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3301
msgid "We know its length exactly, it's ``10000000000000``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3303
msgid ""
"Can predict every of its elements when sub-scripted, sliced, etc., if "
"need be, with a function we may create."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3306
msgid "Similar is true for this horrible (in Python2) thing:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3312
msgid "So it's a rather general problem, this time we know:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3314
msgid "The result is a ``list`` or C level ``PyListObject *``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3316
msgid "We know its length exactly, ``10000000000000``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3318
msgid ""
"Can predict every of its elements when index, sliced, etc., if need be, "
"with a function."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3321
msgid ""
"Again, we wouldn't want to create the list. Therefore Nuitka avoids "
"executing these calculation, when they result in constants larger than a "
"threshold of e.g. 256 elements. This concept has to be also applied to "
"large integers and more CPU and memory traps."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3326
msgid "Now lets look at a more complete use case:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3333
msgid ""
"Looking at this example, one traditional way to look at it, would be to "
"turn ``range`` into ``xrange``, and to note that ``x`` is unused. That "
"would already perform better. But really better is to notice that "
"``range()`` generated values are not used at all, but only the length of "
"the expression matters."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3339
msgid ""
"And even if ``x`` were used, only the ability to predict the value from a"
" function would be interesting, so we would use that computation function"
" instead of having an iteration source. Being able to predict from a "
"function could mean to have Python code to do it, as well as C code to do"
" it. Then code for the loop can be generated without any CPython library "
"usage at all."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3348
msgid ""
"Of course, it would only make sense where such calculations are \"O(1)\" "
"complexity, i.e. do not require recursion like \"n!\" does."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3351
msgid ""
"The other thing is that CPython appears to at - run time - take length "
"hints from objects for some operations, and there it would help too, to "
"track length of objects, and provide it, to outside code."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3355
msgid "Back to the original example:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3361
msgid ""
"The theme here, is that when we can't compute all intermediate "
"expressions, and we sure can't do it in the general case. But we can "
"still, predict some of properties of an expression result, more or less."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3365
msgid ""
"Here we have ``len`` to look at an argument that we know the size of. "
"Great. We need to ask if there are any side effects, and if there are, we"
" need to maintain them of course. This is already done by existing "
"optimization if an operation generates an exception."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3372
msgid ""
"The optimization of ``len`` has been implemented and works for all kinds "
"of container creation and ranges."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3376
msgid "Applying this to \"ctypes\""
msgstr ""

#: ../../doc/doc/developer-manual.rst:3378
msgid ""
"The *not so specific* problem to be solved to understand ``ctypes`` "
"declarations is maybe as follows:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3385
msgid ""
"This leads to Nuitka in its tree to have an assignment from a "
"``__import__`` expression to the variable ``ctypes``. It can be predicted"
" by default to be a module object, and even better, it can be known as "
"``ctypes`` from standard library with more or less certainty. See the "
"section about \"Importing\"."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3391
msgid ""
"So that part is \"easy\", and it's what will happen. During optimization,"
" when the module ``__import__`` expression is examined, it should say:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3394
msgid "``ctypes`` is a module"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3396
msgid "``ctypes`` is from standard library (if it is, might not be true)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3398
msgid ""
"``ctypes`` then has code behind it, called ``ModuleFriend`` that knows "
"things about it attributes, that should be asked."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3401
msgid ""
"The later is the generic interface, and the optimization should connect "
"the two, of course via package and module full names. It will need a "
"``ModuleFriendRegistry``, from which it can be pulled. It would be nice "
"if we can avoid ``ctypes`` to be loaded into Nuitka unless necessary, so "
"these need to be more like a plug-in, loaded only if necessary, i.e. the "
"user code actually uses ``ctypes``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3408
msgid ""
"Coming back to the original expression, it also contains an assignment "
"expression, because it re-formulated to be more like this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3415
msgid ""
"The assigned to object, simply gets the type inferred propagated as part "
"of an SSA form. Ideally, we could be sure that nothing in the program "
"changes the variable, and therefore have only one version of that "
"variable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3420
msgid ""
"For module variables, when the execution leaves the module to unknown "
"code, or unclear code, it might change the variable. Therefore, likely we"
" will often only assume that it could still be ``ctypes``, but also "
"something else."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3425
msgid ""
"Depending on how well we control module variable assignment, we can "
"decide this more of less quickly. With \"compiled modules\" types, the "
"expectation is that it's merely a quick C ``==`` comparison check. The "
"module friend should offer code to allow a check if it applies, for "
"uncertain cases."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3431
msgid "Then when we come to uses of it:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3437
msgid ""
"At this point, using SSA, we are more of less sure, that ``ctypes`` is at"
" that point the module, and that we know what it's ``c_int`` attribute "
"is, at compile time, and what it's call result is. We will use the module"
" friend to help with that. It will attach knowledge about the result of "
"that expression during the SSA collection process."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3443
msgid ""
"This is more like a value forward propagation than anything else. In "
"fact, constant propagation should only be the special case of it, and one"
" design goal of Nuitka was always to cover these two cases with the same "
"code."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3449
msgid "Excursion to Functions"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3451
msgid ""
"In order to decide what this means to functions and their call "
"boundaries, if we propagate forward, how to handle this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3461
msgid ""
"We annotate that ``a`` is first a \"unknown but defined parameter "
"object\", then later on something that definitely has an ``append`` "
"attribute, when returned, as otherwise an exception occurs."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3465
msgid ""
"The type of ``a`` changes to that after ``a.append`` look-up succeeds. It"
" might be many kinds of an object, but e.g. it could have a higher "
"probability of being a ``PyListObject``. And we would know it cannot be a"
" ``PyStringObject``, as that one has no ``append`` method, and would have"
" raised an exception therefore."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3473
msgid ""
"If classes, i.e. other types in the program, have an ``append`` "
"attribute, it should play a role too, there needs to be a way to plug-in "
"to this decisions."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3479
msgid "On the other hand, types without ``append`` attribute can be eliminated."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3482
msgid ""
"Therefore, functions through SSA provide an automatic analysis on their "
"return state, or return value types, or a quick way to predict return "
"value properties, based on input value knowledge."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3486
msgid "So this could work:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3494
msgid ""
"Goal: The structure we use makes it easy to tell what ``my_append`` may "
"be. So, there should be a means to ask it about call results with given "
"type/value information. We need to be able to tell, if evaluating "
"``my_append`` makes sense with given parameters or not, if it does impact"
" the return value."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3500
msgid "We should e.g. be able to make ``my_append`` tell, one or more of these:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3502
msgid ""
"Returns the first parameter value as return value (unless it raises an "
"exception)."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3505
msgid ""
"The return value has the same type as ``a`` (unless it raises an "
"exception)."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3508
msgid "The return value has an ``append`` attribute."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3510
msgid "The return value might be a ``list`` object."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3512
msgid "The return value may not be a ``str`` object."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3514
msgid "The function will raise if first argument has no ``append`` attribute."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3517
msgid ""
"The exactness of statements may vary. But some things may be more "
"interesting. If e.g. the aliasing of a parameter value to the return "
"value is known exactly, then information about it need to all be given "
"up, but some can survive."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3522
msgid ""
"It would be nice, if ``my_append`` had sufficient information, so we "
"could specialize with ``list`` and ``int`` from the parameters, and then "
"e.g. know at least some things that it does in that case. Such "
"specialization would have to be decided if it makes sense. In the "
"alternative, it could be done for each variant anyway, as there won't be "
"that many of them."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3529
msgid ""
"Doing this \"forward\" analysis appears to be best suited for functions "
"and therefore long term. We will try it that way."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3533
msgid "Excursion to Loops"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3548
msgid ""
"The handling of loops (both ``for`` and ``while`` are re-formulated to "
"this kind of loops with ``break`` statements) has its own problem. The "
"loop start and may have an assumption from before it started, that ``a`` "
"is constant, but that is only true for the first iteration. So, we can't "
"pass knowledge from outside loop forward directly into the for loop body."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3555
msgid ""
"So the collection for loops needs to be two pass for loops. First, to "
"collect assignments, and merge these into the start state, before "
"entering the loop body. The need to make two passes is special to loops."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3559
msgid ""
"For a start, it is done like this. At loop entry, all pre-existing, but "
"written traces, are turned into loop merges. Knowledge is not completely "
"removed about everything assigned or changed in the loop, but then it's "
"not trusted anymore."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3564
msgid ""
"From that basis, the ``break`` exits are analysed, and merged, building "
"up the post loop state, and ``continue`` exits of the loop replacing the "
"unknown part of the loop entry state. The loop end is considered a "
"``continue`` for this purpose."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3570
msgid "Excursion to Conditions"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3581
msgid ""
"The above code contains a condition, and these have the problem, that "
"when exiting the conditional block, a merge must be done, of the ``x`` "
"versions. It could be either one. The merge may trace the condition under"
" which a choice is taken. That way, we could decide pairs of traces under"
" the same condition."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3587
msgid ""
"These merges of SSA variable \"versions\", represent alternative values. "
"They pose difficulties, and might have to be reduced to commonality. In "
"the above example, the ``<`` operator will have to check for each "
"version, and then to decide that both indeed give the same result."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3592
msgid ""
"The trace collection tracks variable changes in conditional branches, and"
" then merges the existing state at conditional statement exits."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3597
msgid ""
"A branch is considered \"exiting\" if it is not abortive. Should it end "
"in a ``raise``, ``break``, ``continue``, or ``return``, there is no need "
"to merge that branch, as execution of that branch is terminated."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3601
msgid ""
"Should both branches be abortive, that makes things really simple, as "
"there is no need to even continue."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3604
msgid ""
"Should only one branch exist, but be abortive, then no merge is needed, "
"and the collection can assume after the conditional statement, that the "
"branch was not taken, and continue."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3608
msgid ""
"When exiting both the branches, these branches must both be merged, with "
"their new information."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3611
msgid "In the above case:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3613
msgid ""
"The \"yes\" branch knows variable ``x`` is an ``int`` of constant value "
"``1``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3616
msgid ""
"The \"no\" branch knows variable ``x`` is an ``int`` of constant value "
"``2``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3619
msgid "That might be collapsed to:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3621
msgid "The variable ``x`` is an integer of value in ``(1,2)``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3623
msgid "Given this, we then should be able to pre-compute the value of this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3629
msgid "The comparison operator can therefore decide and tell:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3631
msgid "The variable ``b`` is a boolean of constant value ``True``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3633
msgid "Were it unable to decide, it would still be able to say:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3635
msgid "The variable ``b`` is a boolean."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3637
msgid ""
"For conditional statements optimization, it's also noteworthy, that the "
"condition is known to pass or not pass the truth check, inside branches, "
"and in the case of non-exiting single branches, after the statement it's "
"not true."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3642
msgid "We may want to take advantage of it. Consider e.g."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3651
msgid ""
"In this case, the knowledge that ``a`` is a list, could be used to "
"generate better code and with the definite knowledge that ``a`` is of "
"type list. With that knowledge the ``append`` attribute call will become "
"the ``list`` built-in type operation."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3657
msgid "Excursion to ``return`` statements"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3659
msgid ""
"The ``return`` statement (like ``break``, ``continue``, ``raise``) is "
"\"aborting\" to control flow. It is always the last statement of "
"inspected block. When there statements to follow it, optimization will "
"remove it as \"dead code\"."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3664
msgid ""
"If all branches of a conditional statement are \"aborting\", the "
"statement is decided \"aborting\" too. If a loop doesn't abort with a "
"break, it should be considered \"aborting\" too."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3669
msgid "Excursion to ``yield`` expressions"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3671
msgid ""
"The ``yield`` expression can be treated like a normal function call, and "
"as such invalidates some known constraints just as much as they do. It "
"executes outside code for an unknown amount of time, and then returns, "
"with little about the outside world known anymore, if it's accessible "
"from there."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3678
msgid "Mixed Types"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3680
msgid "Consider the following inside a function or module:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3689
msgid ""
"A programmer will often not make a difference between ``list`` and "
"``tuple``. In fact, using a ``tuple`` is a good way to express that "
"something won't be changed later, as these are mutable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3695
msgid "Better programming style, would be to use this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3704
msgid ""
"People don't do it, because they dislike the performance hit encountered "
"by the generator expression being used to initialize the tuple. But it "
"would be more consistent, and so Nuitka is using it, and of course one "
"day Nuitka ought to be able to make no difference in performance for it."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3710
msgid ""
"To Nuitka though this means, that if ``cond`` is not predictable, after "
"the conditional statement we may either have a ``tuple`` or a ``list`` "
"type object in ``a``. In order to represent that without resorting to \"I"
" know nothing about it\", we need a kind of ``min``/``max`` operating "
"mechanism that is capable of say what is common with multiple alternative"
" values."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3719
msgid ""
"At this time, we don't really have that mechanism to find the commonality"
" between values."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3723
msgid "Back to \"ctypes\""
msgstr ""

#: ../../doc/doc/developer-manual.rst:3729
msgid ""
"Coming back to this example, we needed to propagate ``ctypes``, then we "
"can propagate \"something\" from ``ctypes.int`` and then known what this "
"gives with a call and no arguments, so the walk of the nodes, and diverse"
" operations should be addressed by a module friend."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3734
msgid ""
"In case a module friend doesn't know what to do, it needs to say so by "
"default. This should be enforced by a base class and give a warning or "
"note."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3739
msgid "Now to the interface"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3741
msgid "The following is the intended interface:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3743
msgid ""
"Iteration with node methods ``computeStatement`` and "
"``computeExpression``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3746
msgid ""
"These traverse modules and functions (i.e. scopes) and visit everything "
"in the order that Python executes it. The visiting object is "
"``TraceCollection`` and pass forward. Some node types, e.g. "
"``StatementConditional`` new create branch trace collections and handle "
"the SSA merging at exit."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3752
msgid "Replacing nodes during the visit."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3754
msgid ""
"Both ``computeStatement`` and ``computeExpression`` are tasked to return "
"potential replacements of themselves, together with \"tags\" (meaningless"
" now), and a \"message\", used for verbose tracing."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3758
msgid ""
"The replacement node of ``+`` operator, may e.g. be the pre-computed "
"constant result, wrapped in side effects of the node, or the expression "
"raised, again wrapped in side effects."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3762
msgid "Assignments and references affect SSA."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3764
msgid ""
"The SSA tree is initialized every time a scope is visited. Then during "
"traversal, traces are built up. Every assignment and merge starts a new "
"trace for that matter. References to a given variable version are traced "
"that way."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3769
msgid "Value escapes are traced too."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3771
msgid ""
"When an operation hands over a value to outside code, it indicates so to "
"the trace collection. This is for it to know, when e.g. a constant value,"
" might be mutated meanwhile."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3775
msgid "Nodes can be queried about their properties."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3777
msgid ""
"There is a type shape and a value shape that each node can be asked "
"about. The type shape offers methods that allow to check if certain "
"operations are at all supported or not. These can always return ``True`` "
"(yes), ``False`` (no), and ``None`` (cannot decide). In the case of the "
"later, optimizations may not be able do much about it. Lets call these "
"values \"tri-state\"."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3784
msgid ""
"There is also the value shape of a node. This can go deeper, and be more "
"specific to a given node."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3787
msgid ""
"The default implementation will be very pessimistic. Specific node types "
"and shapes may then declare, that they e.g. have no side effects, will "
"not raise for certain operations, have a known truth value, have a known "
"iteration length, can predict their iteration values, etc."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3793
msgid "Nodes are linked to certain states."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3795
msgid ""
"During the collect, a variable reference, is linked to a certain trace "
"state, and that can be used by parent operations."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3803
msgid ""
"In this example, the references to ``a``, can look-up the ``1`` in the "
"trace, and base value shape response to ``+`` on it. For compile time "
"evaluation, it may also ask ``isCompileTimeConstant()`` and if both nodes"
" will respond ``True``, then \"getCompileTimeConstant()\" will return "
"``1``, which will be be used in computation."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3809
msgid ""
"Then ``extractSideEffects()`` for the ``a`` reference will return ``()`` "
"and therefore, the result ``2`` will not be wrapped."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3812
msgid ""
"An alternative approach would be ``hasTypeSlotAdd()`` on the both nodes, "
"and they both do, to see if the selection mechanism used by CPython can "
"be used to find which types ``+`` should be used."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3816
msgid "Class for module import expression ``ExpressionImportModule``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3818
msgid ""
"This one just knows that something is imported, but not how or what it is"
" assigned to. It will be able in a recursive compile, to provide the "
"module as an assignment source, or the module variables or submodules as "
"an attribute source when referenced from a variable trace or in an "
"expression."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3824
msgid "Base class for module friend ``ModuleFriendBase``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3826
msgid ""
"This is intended to provide something to overload, which e.g. can handle "
"``math`` in a better way."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3829
msgid "Module ``ModuleFriendRegistry``"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3831
msgid ""
"Provides a register function with ``name`` and instances of "
"``ValueFriendModuleBase`` to be registered. Recursed to modules should "
"integrate with that too. The registry could well be done with a metaclass"
" approach."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3836
msgid "The module friends should each live in a module of their own."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3838
msgid ""
"With a naming policy to be determined. These modules should add "
"themselves via above mechanism to ``ModuleFriendRegistry`` and all shall "
"be imported and register. Importing of e.g. ``ctypes`` should be delayed "
"to when the friend is actually used. A meta class should aid this task."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3844
msgid ""
"The delay will avoid unnecessary blot of the compiler at run time, if no "
"such module is used. For \"qt\" and other complex stuff, this will be a "
"must."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3848
msgid "The walk should initially be single pass, and not maintain history."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3850
msgid ""
"Instead optimization that needs to look at multiple things, e.g. \"unused"
" assignment\", will look at the whole SSA collection afterwards."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3855
msgid "Discussing with examples"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3857
msgid "The following examples:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3882
msgid ""
"The optimization is mostly performed by walking of the tree and "
"performing trace collection. When it encounters assignments and "
"references to them, it considers current state of traces and uses it for "
"``computeExpression``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3889
msgid ""
"Assignments to attributes, indexes, slices, etc. will also need to follow"
" the flow of ``append``, so it cannot escape attention that a list may be"
" modified. Usages of ``append`` that we cannot be sure about, must be "
"traced to exist, and disallow the list to be considered known value "
"again."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3896
msgid "Code Generation Impact"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3898
msgid ""
"Right now, code generation assumes that everything is a ``PyObject *``, "
"i.e. a Python object, and does not take knowledge of ``int`` or other "
"types into consideration at all, and it should remain like that for some "
"time to come."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3903
msgid ""
"Instead, ``ctypes`` value friend will be asked give ``Identifiers``, like"
" other codes do too. And these need to be able to convert themselves to "
"objects to work with the other things."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3907
msgid ""
"But Code Generation should no longer require that operations must be "
"performed on that level. Imagine e.g. the following calls:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3914
msgid ""
"Value returned by \"other_c_call()\" of say ``c_int`` type, should be "
"possible to be fed directly into another call. That should be easy by "
"having a ``asIntC()`` in the identifier classes, which the ``ctypes`` "
"Identifiers handle without conversions."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3919
msgid ""
"Code Generation should one day also become able to tell that all uses of "
"a variable have only ``c_int`` value, and use ``int`` instead of "
"``PyObjectLocalVariable`` more or less directly. We could consider "
"``PyIntLocalVariable`` of similar complexity as ``int`` after the C++ "
"compiler performed its in-lining."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3925
msgid ""
"Such decisions would be prepared by finalization, which then would track "
"the history of values throughout a function or part of it."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3929
msgid "Initial Implementation"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3931
msgid ""
"The basic interface will be added to *all* expressions and a node may "
"override it, potentially using trace collection state, as attached during"
" ``computeExpression``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3936
msgid "Goal 1 (Reached)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3938
msgid ""
"Initially most things will only be able to give up on about anything. And"
" it will be little more than a tool to do simple look-ups in a general "
"form. It will then be the first goal to turn the following code into "
"better performing one:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3950
msgid "to:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3959
#: ../../doc/doc/developer-manual.rst:3968
msgid "and then:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3977
msgid ""
"This depends on SSA form to be able to tell us the values of ``a``, "
"``b``, and ``c`` to be written to by constants, which can be forward "
"propagated at no cost."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3982
msgid "Goal 2 (Reached)"
msgstr ""

#: ../../doc/doc/developer-manual.rst:3984
msgid ""
"The assignments to ``a``, ``b``, and ``c`` shall all become prey to "
"\"unused\" assignment analysis in the next step. They are all only "
"assigned to, and the assignment source has no effect, so they can be "
"simply dropped."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3993
msgid ""
"In the SSA form, these are then assignments without references. These "
"assignments, can be removed if the assignment source has no side effect. "
"Or at least they could be made \"anonymous\", i.e. use a temporary "
"variable instead of the named one. That would have to take into account "
"though, that the old version still needs a release."
msgstr ""

#: ../../doc/doc/developer-manual.rst:3999
msgid ""
"The most general form would first merely remove assignments that have no "
"impact, and leave the value as a side effect, so we arrive at this first:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4010
msgid ""
"When applying the removal of expression only statements without effect, "
"this gives us:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4017
msgid ""
"which is the perfect result. Doing it in one step would only be an "
"optimization at the cost of generalization."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4020
msgid ""
"In order to be able to manipulate nodes related to a variable trace, we "
"need to attach the nodes that did it. Consider this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4033
msgid ""
"In the above case, the merge of the value traces, should say that ``x`` "
"may be undefined, or one of ``1`` or ``3``, but since ``x`` is not used, "
"apply the \"dead value\" trick to each branch."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4037
msgid ""
"The removal of the \"merge\" of the 3 ``x`` versions, should exhibit that"
" the other versions are also only assigned to, and can be removed. These "
"merges of course appear as usages of the ``x`` versions."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4042
msgid "Goal 3"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4044
msgid "Then third goal is to understand all of this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4062
msgid ""
"There are many operations in this, and all of them should be properly "
"handled, or at least ignored in safe way."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4065
msgid ""
"The first goal code gave us that the ``list`` has an annotation from the "
"assignment of ``[]`` and that it will be copied to ``a`` until the for "
"loop in encountered. Then it must be removed, because the ``for`` loop "
"somehow says so."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4070
msgid ""
"The ``a`` may change its value, due to the unknown attribute look-up of "
"it already, not even the call. The for loop must be able to say \"may "
"change value\" due to that, of course also due to the call of that "
"attribute too."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4075
msgid "The code should therefore become equivalent to:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4091
msgid ""
"But no other changes must occur, especially not to the ``return`` "
"statement, it must not assume ``a`` to be constant \"[]\" but an unknown "
"``a`` instead."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4095
msgid ""
"With that, we would handle this code correctly and have some form "
"constant value propagation in place, handle loops at least correctly, and"
" while it is not much, it is important demonstration of the concept."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4100
msgid "Goal 4"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4102
msgid "The fourth goal is to understand the following:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4116
msgid ""
"In this we have a branch, and we will be required to keep track of both "
"the branches separately, and then to merge with the original knowledge. "
"After the conditional statement we will know that \"x\" is an \"int\" "
"with possible values in ``(1,2)``, which can be used to predict that the "
"return value is always ``True``."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4122
msgid ""
"The forth goal will therefore be that the \"ValueFriendConstantList\" "
"knows that append changes ``a`` value, but it remains a list, and that "
"the size increases by one. It should provide an other value friend "
"\"ValueFriendList\" for \"a\" due to that."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4127
msgid "In order to do that, such code must be considered:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4138
msgid ""
"It will be good, if ``len`` still knows that ``a`` is a list object, but "
"not the constant list anymore."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4141
msgid ""
"From here, work should be done to demonstrate the correctness of it with "
"the basic tests applied to discover undetected issues."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4144
msgid ""
"Fifth and optional goal: Extra bonus points for being able to track and "
"predict ``append`` to update the constant list in a known way. Using "
"``list.append`` that should be done and lead to a constant result of "
"``len`` being used."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4149
msgid ""
"The sixth and challenging goal will be to make the code generation be "
"impacted by the value friends types. It should have a knowledge that "
"``PyList_Append`` does the job of append and use ``PyList_Size`` for "
"``len``. The \"ValueFriends\" should aid the code generation too."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4154
msgid ""
"Last and right now optional goal will be to make ``range`` have a value "
"friend, that can interact with iteration of the for loop, and ``append`` "
"of the ``list`` value friend, so it knows it's possible to iterate 5000 "
"times, and that \"a\" has then after the \"loop\" this size, so "
"``len(a)`` could be predicted. For during the loop, about a the range of "
"its length should be known to be less than 5000. That would make the code"
" of goal 2 completely analyzed at compile time."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4163
msgid "Limitations for now"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4165
msgid ""
"Aim only for limited examples. For ``ctypes`` that means to compile time "
"evaluate:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4172
msgid ""
"Later then call to \"libc\" or something else universally available, e.g."
" \"strlen()\" or \"strcmp()\" from full blown declarations of the "
"callable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4176
msgid ""
"We won't have the ability to test that optimization are actually "
"performed, we will check the generated code by hand."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4179
msgid ""
"With time, we will add XML based checks with \"xpath\" queries, expressed"
" as hints, but that is some work that will be based on this work here. "
"The \"hints\" fits into the \"ValueFriends\" concept nicely or so the "
"hope is."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4184
msgid "No inter-function optimization functions yet"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4186
msgid ""
"Of course, once in place, it will make the ``ctypes`` annotation even "
"more usable. Using ``ctypes`` objects inside functions, while creating "
"them on the module level, is therefore not immediately going to work."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4191
msgid "No loops yet"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4193
msgid ""
"Loops break value propagation. For the ``ctypes`` use case, this won't be"
" much of a difficulty. Due to the strangeness of the task, it should be "
"tackled later on at a higher priority."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4197
msgid "Not too much."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4199
msgid ""
"Try and get simple things to work now. We shall see, what kinds of "
"constraints really make the most sense. Understanding ``list`` "
"subscript/slice values e.g. is not strictly useful for much code and "
"should not block us."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4206
msgid "This design is not likely to be the final one."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4210
msgid "How to make Features Experimental"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4212
msgid ""
"Every experimental feature needs a name. We have a rule to pick a name "
"with lower case and ``_`` as separators. An example of with would be the "
"name ``jinja_generated_add`` that has been used in the past."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4217
msgid "Command Line"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4219
msgid "Experimental features are enabled with the command line argument"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4226
msgid "In C code"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4228
msgid ""
"In Scons, all experimental features automatically are converted into C "
"defines, and can be used like this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4239
msgid ""
"The C pre-processor is the only thing that makes an experimental feature "
"usable."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4243
msgid "In Python"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4245
msgid ""
"You can query experimental features using ``Options.isExperimental()`` "
"with e.g. code like this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4256
msgid "When to use it"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4258
msgid ""
"Often we need to keep feature in parallel because they are not finished, "
"or need to be tested after merge and should not break. Then we can do "
"code changes that will not make a difference except when the experimental"
" flag is given on the command line to Nuitka."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4263
msgid ""
"The testing of Nuitka is very heavy weight when e.g. all Python code is "
"compiled, and very often, it is interesting to compare behavior with and "
"without a change."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4268
msgid "When to remove it"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4270
msgid ""
"When a feature becomes default, we might choose to keep the old variant "
"around, but normally we do not. Then we remove the ``if`` and ``#if`` "
"checks and drop the old code."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4274
msgid ""
"At this time, large scale testing will have demonstrated the viability of"
" the code."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4279
msgid "Adding dependencies to Nuitka"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4281
msgid ""
"First of all, there is an important distinction to make, runtime or "
"development time. The first kind of dependency is used when Nuitka is "
"executing."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4286
msgid "Adding a Runtime Dependency"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4288
msgid ""
"This is the kind of dependency that is the most scrutinized. As we want "
"Nuitka to run on latest greatest Python as well as relatively old ones, "
"we have to be very careful with these ones."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4292
msgid ""
"There is also a distinction of optional dependencies. Right now e.g. the "
"``lxml`` package is relatively optional, and Nuitka can work without it "
"being installed, because e.g. on some platforms it will not be easy to do"
" so. That bar has lifted somewhat, but it means e.g. that XML based "
"optimization tests are not run with all Python versions."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4298
msgid ""
"The list of runtime dependencies is in ``requirements.txt`` and it is for"
" those the case, that they are not really required to be installed by the"
" user, consider this snippet:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4310
msgid ""
"For both these dependencies, there is either an inline copy (Scons) that "
"we handle to use in case, if Scons is not available (in fact we have a "
"version that works with Python 2.6 and 2.7 still), and also the same for "
"appdirs and every dependency."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4315
msgid ""
"But since inline copies are against the rules on some platforms that "
"still do not contain the package, we often even have our own wrapper "
"which provides a minimal fallback or exposes a sane interface for the "
"subset of functionality that we use."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4322
msgid ""
"Therefore, please if you consider adding one of these, get in touch with "
"``@Nuitka-pushers`` first and get a green light."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4326
msgid "Adding a Development Dependency"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4328
msgid ""
"A typical example of a development dependency is ``black`` which is used "
"by our autoformat tool, and then in turn by the git pre-commit hook. It "
"is used to format source code, and doesn't have a role at run time of the"
" actual compiler code of Nuitka."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4333
msgid ""
"Much less strict rules apply to these in comparison to runtime "
"dependencies. Generally please take care that the tool must be well "
"maintained an available on newer Pythons. Then we can use it, no problem "
"normally. But if it's really big, say all of SciPy, we might want to "
"justify it a bit better."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4339
msgid ""
"The list of development dependencies is in ``requirements-devel.txt`` and"
" it is for example like this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4347
msgid ""
"We always add the version, so that when tests run on as old versions as "
"Python 2.6, the installation would fail with that version, so we need to "
"make a version requirement. Sometimes we use older versions for Python2 "
"than for Python3, ``Jinaj2`` being a notable candidate, but generally we "
"ought to avoid that. For many tools only being available for currently "
"3.7 or higher is good enough, esp. if they are run as development tools, "
"like ``autoformat-nuitka-source`` is."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4357
msgid "Idea Bin"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4359
msgid ""
"This an area where to drop random ideas on our minds, to later sort it "
"out, and out it into action, which could be code changes, plan changes, "
"issues created, etc."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4363
msgid "Make \"SELECT_METACLASS\" meta class selection transparent."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4365
msgid ""
"Looking at the \"SELECT_METACLASS\" it should become an anonymous helper "
"function. In that way, the optimization process can remove choices at "
"compile time, and e.g. in-line the effect of a meta class, if it is "
"known."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4370
msgid ""
"This of course makes most sense, if we have the optimizations in place "
"that will allow this to actually happen."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4373
msgid "Keeping track of iterations"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4375
msgid ""
"The trace collection trace should become the place, where variables or "
"values track their use state. The iterator should keep track of the "
"\"next()\" calls made to it, so it can tell which value to given in that "
"case."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4380
msgid ""
"That would solve the \"iteration of constants\" as a side effect and it "
"would allow to tell that they can be removed."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4383
msgid "That would mean to go back in the tree and modify it long after."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4392
msgid "It would be sweet if we could recognize that as:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4401
msgid "That trivially becomes:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4412
msgid ""
"When the ``del a`` is examined at the end of scope, or due to another "
"assignment to the same variable, ending the trace, we would have to "
"consider of the ``next`` uses, and retrofit the information that they had"
" no effect."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4424
msgid "Aliasing"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4426
msgid ""
"Each time an assignment is made, an alias is created. A value may have "
"different names."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4436
msgid ""
"If we fail to detect the aliasing nature, we will calculate ``d`` "
"wrongly. We may incref and decref values to trace it."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4439
msgid ""
"Aliasing is automatically traced already in SSA form. The ``b`` is "
"assigned to version of ``a``. So, that should allow to replace it with "
"this:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4449
msgid "Which then will be properly handled."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4451
msgid "Tail recursion optimization."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4453
msgid ""
"Functions that return the results of calls, can be optimized. The "
"Stackless Python does it already."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4456
msgid "Integrate with \"upx\" compression."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4458
msgid "Calling \"upx\" on the created binaries, would be easy."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4460
msgid "In-lining constant \"exec\" and \"eval\"."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4462
msgid ""
"It should be possible to re-formulate at least cases without \"locals\" "
"or \"globals\" given."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4475
msgid "Should become this here:"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4488
msgid "If this holds up, inlining ``exec`` should be relatively easy."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4490
msgid "Original and overloaded built-ins"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4492
msgid ""
"This is about making things visible in the node tree. In Nuitka things "
"that are not visible in the node tree tend to be wrong. We already pushed"
" around information to the node tree a lot."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4496
msgid ""
"Later versions, Nuitka will become able to determine it has to be the "
"original built-in at compile time, then a condition that checks will be "
"optimized away, together with the slow path. Or the other path, if it "
"won't be. Then it will be optimized away, or if doubt exists, it will be "
"correct. That is the goal."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4502
msgid ""
"Right now, the change would mean to effectively disable all built-in call"
" optimization, which is why we don't immediately do it."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4505
msgid ""
"Making the compatible version, will also require a full listing of all "
"built-ins, which is typing work merely, but not needed now. And a way to "
"stop built-in optimization from optimizing built-in calls that it used in"
" a wrap. Probably just some flag to indicate it when it visits it to skip"
" it. That's for later."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4511
msgid ""
"But should we have that both, I figure, we could not raise a "
"``RuntimeError`` error, but just do the correct thing, in all cases. An "
"earlier step may raise ``RuntimeError`` error, when built-in module "
"values are written to, that we don't support."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4518
msgid "Prongs of Action"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4520
msgid ""
"In this chapter, we keep track of prongs of action currently ongoing. "
"This can get detailed and shows things we strive for."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4524
msgid "Builtin optimization"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4526
msgid ""
"Definitely want to get built-in names under full control, so that "
"variable references to module variables do not have a twofold role. "
"Currently they reference the module variable and also the potential "
"built-in as a fallback."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4531
msgid ""
"In terms of generated code size and complexity for modules with many "
"variables and uses of them that is horrible. But ``some_var`` (normally) "
"cannot be a built-in and therefore needs no code to check for that each "
"time."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4536
msgid ""
"This is also critical to getting to whole program optimization. Being "
"certain what is what there on module level, will enable more definitely "
"knowledge about data flows and module interfaces."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4541
msgid "Class Creation Overhead Reduction"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4543
msgid ""
"This is more of a meta goal. Some work for the metaclass has already been"
" done, but that is Python2 only currently. Being able to to decide built-"
"ins and to distinguish between global only variables, and built-ins more "
"clearly will help this a lot."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4548
msgid ""
"In the end, empty classes should be able to be statically converted to "
"calls to ``type`` with static dictionaries. The inlining of class "
"creation function is also needed for this, but on Python3 cannot happen "
"yet."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4554
msgid "Memory Usage at Compile Time"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4556
msgid ""
"We will need to store more and more information in the future. Getting "
"the tree to be tight shaped is therefore an effort, where we will be "
"spending time too."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4560
msgid ""
"The mix-ins prevent slots usage, so lets try and get rid of those. The "
"\"children having\" should become more simple and faster code. I am even "
"thinking of even generating code in the meta class, so it's both optimal "
"and doesn't need that mix-in any more. This is going to be ugly then."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4566
msgid "Coverage Testing"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4568
msgid ""
"And then there is coverage, it should be taken and merged from all Python"
" versions and OSes, but I never managed to merge between Windows and "
"Linux for unknown reasons."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4573
msgid "Python3 Performance"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4575
msgid ""
"The Python3 lock for thread state is making it slower by a lot. I have "
"only experimental code that just ignores the lock, but it likely only "
"works on Linux, and I wonder why there is that lock in the first place."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4579
msgid ""
"Ignoring the locks cannot be good. But what updates that thread state "
"pointer ever without a thread change, and is this what ABI flags are "
"about in this context, are there some that allow us to ignore the locks."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4583
msgid ""
"An important bit would be to use a thread state once acquired for as much"
" as possible, currently exception helpers do not accept it as an "
"argument, but that ought to become an option, that way saving and "
"restoring an exception will be much faster, not to mention checking and "
"dropping non interesting, or rewriting exceptions."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4590
msgid "Caching of Python level compilation"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4592
msgid ""
"While the C compilation result is already cached with ccache and friends "
"now, we need to also cover our bases and save the resulting node tree of "
"potential expensive optimization on the module level."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4598
msgid "Updates for this Manual"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4600
msgid ""
"This document is written in REST. That is an ASCII format which is "
"readable to human, but easily used to generate PDF or HTML documents."
msgstr ""

#: ../../doc/doc/developer-manual.rst:4603
msgid ""
"You will find the current source under: "
"https://github.com/Nuitka/Nuitka/blob/develop/Developer_Manual.rst"
msgstr ""

#: ../../doc/doc/developer-manual.rst:4606
msgid "And the current PDF under: https://nuitka.net/doc/Developer_Manual.pdf"
msgstr ""

#~ msgid "Another one we found useful to collaborate:"
#~ msgstr "另一个我们发现有用的合作："

#~ msgid "Live Share (``ms-vsliveshare.vsliveshare``)"
#~ msgstr ""

#~ msgid "Stable (master branch)"
#~ msgstr ""

#~ msgid "Development (develop branch)"
#~ msgstr ""

#~ msgid ""
#~ "Same as factory, but not integrated "
#~ "as factory normally is, and not "
#~ "rebased all the time. For some "
#~ "branches, they will be rebased as "
#~ "a service when we update develop."
#~ msgstr ""

#~ msgid ""
#~ "Every class and every method **must "
#~ "be documented** via the standard Python"
#~ " delimiters (``\"\"\" ... \"\"\"``) in "
#~ "the usual way."
#~ msgstr ""

#~ msgid "Recursion checks are expensive."
#~ msgstr ""

#~ msgid ""
#~ "If the \"caller\" or the \"called\" "
#~ "can declare that it cannot be "
#~ "called by itself, we could leave "
#~ "it out."
#~ msgstr ""

#~ msgid ""
#~ "TODO: Are they really that expensive?"
#~ " Unnecessary yes, but expensive may "
#~ "not be true."
#~ msgstr ""

#~ msgid "Contents"
#~ msgstr ""

#~ msgid ""
#~ "The tool (mostly ``black`` and "
#~ "``isort``) encodes all formatting rules, "
#~ "and makes the decisions for us. "
#~ "The idea being that we can focus"
#~ " on actual code and do not have"
#~ " to care as much about other "
#~ "things. It also deals with Windows "
#~ "new lines, trailing space, etc. and "
#~ "even sorts pylint disable statements."
#~ msgstr ""

#~ msgid "We are replacing doxygen with sphinx, this is all obsolete"
#~ msgstr ""

#~ msgid ""
#~ "The documentation from the source code"
#~ " for both the Python and the C"
#~ " parts are published as `Nuitka API"
#~ " <https://nuitka.net/apidoc>`__ and argumently in"
#~ " a relatively bad shape as we "
#~ "started generating those with Doxygen "
#~ "only relatively late."
#~ msgstr ""

#~ msgid "``unstriped_mode``"
#~ msgstr ""

#~ msgid "Unstriped mode: Do not remove debug symbols."
#~ msgstr ""

#~ msgid ""
#~ "Only string objects are spared from "
#~ "the ``str`` built-in wrapper, because"
#~ " that would only cause noise in "
#~ "optimization stage. Later optization can "
#~ "then find it unnecessary for certain "
#~ "arguments."
#~ msgstr ""

#~ msgid ""
#~ "When assigning ``a`` to something new,"
#~ " that won't change ``b`` at all. "
#~ "But when an attribute is set, a"
#~ " method called of it, that might "
#~ "impact the actual value, referenced by"
#~ " both. We need to understand mutable"
#~ " vs. immutable though, as some things"
#~ " are not affectable by aliasing in"
#~ " any way."
#~ msgstr ""

#~ msgid "Given this, we then should be able to precompute the value of this:"
#~ msgstr ""

#~ msgid ""
#~ "Ignoring the locks cannot be good. "
#~ "But what updates that thread state "
#~ "pointer ever without a thread change,"
#~ " and is this what abiflags are "
#~ "about in this context, are there "
#~ "some that allow us to ignore the"
#~ " locks."
#~ msgstr ""

#~ msgid "Onefile compression on Windows"
#~ msgstr ""

#~ msgid ""
#~ "We need to add compression on that"
#~ " platform too. This should use zstd"
#~ " and probably just needs integration "
#~ "into our build. The Python side "
#~ "already is capable of producing "
#~ "compressed payload."
#~ msgstr ""

#~ msgid ""
#~ "For Nuitka we use a defensive "
#~ "version numbering system to indicate "
#~ "that it is not yet ready for "
#~ "everything. We have defined milestones "
#~ "and the version numbers should express"
#~ " which of these, we consider done."
#~ msgstr ""
#~ "对于 "
#~ "Nuitka，我们使用了一个防御性的版本编号系统，以表明它还没有准备好一切。我们已经定义了里程碑，版本号应该表达其中哪些，我们认为已经完成了。"

#~ msgid "So far:"
#~ msgstr "到目前为止："

#~ msgid ""
#~ "Before milestone 1, we used ``0.1.x``"
#~ " version numbers. After reaching it, "
#~ "we used ``0.2.x`` version numbers."
#~ msgstr "在里程碑 1 之前，我们使用 ``0.1.x`` 的版本号。达到之后，我们使用 ``0.2.x`` 的版本号。"

#~ msgid ""
#~ "Before milestone 2 and 3, we used"
#~ " ``0.3.x`` version numbers. After almost"
#~ " reaching 3, and beginning with 4,"
#~ " we use \"0.4.x\" version numbers. "
#~ "Due to an interface change, ``0.5.x``"
#~ " version numbers are being used."
#~ msgstr ""
#~ "在里程碑 2 和 3 之前，我们使用 ``0.3.x`` "
#~ "的版本号。在几乎达到 3 之后，从 4 开始，我们使用 \"0.4.x\""
#~ " 的版本号。由于接口的改变，正在使用 ``0.5.x`` 的版本号。"

#~ msgid ""
#~ "Due to reaching type inference in "
#~ "code generation, even if only starting,"
#~ " the ``0.6.x`` version numbers were "
#~ "started to be used. This stage "
#~ "should allow quick progress in "
#~ "performance for individual releases."
#~ msgstr "由于在代码生成中达到了类型推理，即使只是开始，也开始使用 ``0.6.x`` 的版本号了。这个阶段应该允许个别版本的性能快速进步。"

#~ msgid "Future:"
#~ msgstr "未来："

#~ msgid "With ``ctypes`` bindings in a usable state it will be ``0.7.x``."
#~ msgstr "在 ``ctypes`` 绑定处于可用状态时，它将是 ``0.7.x``。"

#~ msgid "Final:"
#~ msgstr "最终："

#~ msgid ""
#~ "We will then round it up and "
#~ "call it Nuitka ``1.0`` when this "
#~ "works as expected for a bunch of"
#~ " people. The plan is to reach "
#~ "this goal during 2021. This is "
#~ "based on positive assumptions that may"
#~ " not hold up though."
#~ msgstr ""
#~ "然后我们将把它围起来，当这对一群人来说如预期的那样工作时，就称之为Nuitka ``1.0``。计划是在 2021"
#~ " 年期间达到这个目标。这是基于积极的假设，但可能不成立。"

#~ msgid "Of course, all of this may be subject to change."
#~ msgstr "当然，所有这些都可能会有变化。"

